code
proc swapfunc 24 0
file "../../../code/game/bg_lib.c"
line 76
;1://
;2://
;3:// bg_lib,c -- standard C library replacement routines used by code
;4:// compiled for the virtual machine
;5:
;6:#ifdef Q3_VM
;7:
;8:#include "../qcommon/q_shared.h"
;9:
;10:/*-
;11: * Copyright (c) 1992, 1993
;12: *	The Regents of the University of California.  All rights reserved.
;13: *
;14: * Redistribution and use in source and binary forms, with or without
;15: * modification, are permitted provided that the following conditions
;16: * are met:
;17: * 1. Redistributions of source code must retain the above copyright
;18: *    notice, this list of conditions and the following disclaimer.
;19: * 2. Redistributions in binary form must reproduce the above copyright
;20: *    notice, this list of conditions and the following disclaimer in the
;21: *    documentation and/or other materials provided with the distribution.
;22: * 3. Neither the name of the University nor the names of its contributors
;23: *    may be used to endorse or promote products derived from this software
;24: *    without specific prior written permission.
;25: *
;26: * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
;27: * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
;28: * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
;29: * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
;30: * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
;31: * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
;32: * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
;33: * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
;34: * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
;35: * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
;36: * SUCH DAMAGE.
;37: */
;38:
;39:#include "bg_lib.h"
;40:
;41:#if defined(LIBC_SCCS) && !defined(lint)
;42:#if 0
;43:static char sccsid[] = "@(#)qsort.c	8.1 (Berkeley) 6/4/93";
;44:#endif
;45:static const char rcsid[] =
;46:#endif /* LIBC_SCCS and not lint */
;47:
;48:static char* med3(char *, char *, char *, cmp_t *);
;49:static void	 swapfunc(char *, char *, int, int);
;50:
;51:#ifndef min
;52:#define min(a, b)	((a) < (b) ? (a) : (b))
;53:#endif
;54:
;55:/*
;56: * Qsort routine from Bentley & McIlroy's "Engineering a Sort Function".
;57: */
;58:#define swapcode(TYPE, parmi, parmj, n) { 		\
;59:	long i = (n) / sizeof (TYPE); 			\
;60:	register TYPE *pi = (TYPE *) (parmi); 		\
;61:	register TYPE *pj = (TYPE *) (parmj); 		\
;62:	do { 						\
;63:		register TYPE	t = *pi;		\
;64:		*pi++ = *pj;				\
;65:		*pj++ = t;				\
;66:        } while (--i > 0);				\
;67:}
;68:
;69:#define SWAPINIT(a, es) swaptype = ((char *)a - (char *)0) % sizeof(long) || \
;70:	es % sizeof(long) ? 2 : es == sizeof(long)? 0 : 1;
;71:
;72:static void
;73:swapfunc(a, b, n, swaptype)
;74:	char *a, *b;
;75:	int n, swaptype;
;76:{
line 77
;77:	if(swaptype <= 1)
ADDRFP4 12
INDIRI4
CNSTI4 1
GTI4 $24
line 78
;78:		swapcode(long, a, b, n)
ADDRLP4 8
ADDRFP4 8
INDIRI4
CVIU4 4
CNSTI4 2
RSHU4
CVUI4 4
ASGNI4
ADDRLP4 0
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 4
ADDRFP4 4
INDIRP4
ASGNP4
LABELV $26
ADDRLP4 12
ADDRLP4 0
INDIRP4
INDIRI4
ASGNI4
ADDRLP4 16
ADDRLP4 0
INDIRP4
ASGNP4
ADDRLP4 0
ADDRLP4 16
INDIRP4
CNSTI4 4
ADDP4
ASGNP4
ADDRLP4 16
INDIRP4
ADDRLP4 4
INDIRP4
INDIRI4
ASGNI4
ADDRLP4 20
ADDRLP4 4
INDIRP4
ASGNP4
ADDRLP4 4
ADDRLP4 20
INDIRP4
CNSTI4 4
ADDP4
ASGNP4
ADDRLP4 20
INDIRP4
ADDRLP4 12
INDIRI4
ASGNI4
LABELV $27
ADDRLP4 12
ADDRLP4 8
INDIRI4
CNSTI4 1
SUBI4
ASGNI4
ADDRLP4 8
ADDRLP4 12
INDIRI4
ASGNI4
ADDRLP4 12
INDIRI4
CNSTI4 0
GTI4 $26
ADDRGP4 $25
JUMPV
LABELV $24
line 80
;79:	else
;80:		swapcode(char, a, b, n)
ADDRLP4 8
ADDRFP4 8
INDIRI4
CVIU4 4
CVUI4 4
ASGNI4
ADDRLP4 0
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 4
ADDRFP4 4
INDIRP4
ASGNP4
LABELV $29
ADDRLP4 12
ADDRLP4 0
INDIRP4
INDIRI1
ASGNI1
ADDRLP4 16
ADDRLP4 0
INDIRP4
ASGNP4
ADDRLP4 0
ADDRLP4 16
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 16
INDIRP4
ADDRLP4 4
INDIRP4
INDIRI1
ASGNI1
ADDRLP4 20
ADDRLP4 4
INDIRP4
ASGNP4
ADDRLP4 4
ADDRLP4 20
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 20
INDIRP4
ADDRLP4 12
INDIRI1
ASGNI1
LABELV $30
ADDRLP4 12
ADDRLP4 8
INDIRI4
CNSTI4 1
SUBI4
ASGNI4
ADDRLP4 8
ADDRLP4 12
INDIRI4
ASGNI4
ADDRLP4 12
INDIRI4
CNSTI4 0
GTI4 $29
LABELV $25
line 81
;81:}
LABELV $23
endproc swapfunc 24 0
proc med3 40 8
line 97
;82:
;83:#define swap(a, b)					\
;84:	if (swaptype == 0) {				\
;85:		long t = *(long *)(a);			\
;86:		*(long *)(a) = *(long *)(b);		\
;87:		*(long *)(b) = t;			\
;88:	} else						\
;89:		swapfunc(a, b, es, swaptype)
;90:
;91:#define vecswap(a, b, n) 	if ((n) > 0) swapfunc(a, b, n, swaptype)
;92:
;93:static char *
;94:med3(a, b, c, cmp)
;95:	char *a, *b, *c;
;96:	cmp_t *cmp;
;97:{
line 98
;98:	return cmp(a, b) < 0 ?
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 20
ADDRFP4 12
INDIRP4
CALLI4
ASGNI4
ADDRLP4 20
INDIRI4
CNSTI4 0
GEI4 $38
ADDRFP4 4
INDIRP4
ARGP4
ADDRFP4 8
INDIRP4
ARGP4
ADDRLP4 24
ADDRFP4 12
INDIRP4
CALLI4
ASGNI4
ADDRLP4 24
INDIRI4
CNSTI4 0
GEI4 $40
ADDRLP4 4
ADDRFP4 4
INDIRP4
ASGNP4
ADDRGP4 $41
JUMPV
LABELV $40
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 8
INDIRP4
ARGP4
ADDRLP4 28
ADDRFP4 12
INDIRP4
CALLI4
ASGNI4
ADDRLP4 28
INDIRI4
CNSTI4 0
GEI4 $42
ADDRLP4 8
ADDRFP4 8
INDIRP4
ASGNP4
ADDRGP4 $43
JUMPV
LABELV $42
ADDRLP4 8
ADDRFP4 0
INDIRP4
ASGNP4
LABELV $43
ADDRLP4 4
ADDRLP4 8
INDIRP4
ASGNP4
LABELV $41
ADDRLP4 0
ADDRLP4 4
INDIRP4
ASGNP4
ADDRGP4 $39
JUMPV
LABELV $38
ADDRFP4 4
INDIRP4
ARGP4
ADDRFP4 8
INDIRP4
ARGP4
ADDRLP4 32
ADDRFP4 12
INDIRP4
CALLI4
ASGNI4
ADDRLP4 32
INDIRI4
CNSTI4 0
LEI4 $44
ADDRLP4 12
ADDRFP4 4
INDIRP4
ASGNP4
ADDRGP4 $45
JUMPV
LABELV $44
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 8
INDIRP4
ARGP4
ADDRLP4 36
ADDRFP4 12
INDIRP4
CALLI4
ASGNI4
ADDRLP4 36
INDIRI4
CNSTI4 0
GEI4 $46
ADDRLP4 16
ADDRFP4 0
INDIRP4
ASGNP4
ADDRGP4 $47
JUMPV
LABELV $46
ADDRLP4 16
ADDRFP4 8
INDIRP4
ASGNP4
LABELV $47
ADDRLP4 12
ADDRLP4 16
INDIRP4
ASGNP4
LABELV $45
ADDRLP4 0
ADDRLP4 12
INDIRP4
ASGNP4
LABELV $39
ADDRLP4 0
INDIRP4
RETP4
LABELV $32
endproc med3 40 8
export qsort
proc qsort 104 16
line 108
;99:	       (cmp(b, c) < 0 ? b : (cmp(a, c) < 0 ? c : a ))
;100:              :(cmp(b, c) > 0 ? b : (cmp(a, c) < 0 ? a : c ));
;101:}
;102:
;103:void
;104:qsort(a, n, es, cmp)
;105:	void *a;
;106:	size_t n, es;
;107:	cmp_t *cmp;
;108:{
LABELV $49
line 112
;109:	char *pa, *pb, *pc, *pd, *pl, *pm, *pn;
;110:	int d, r, swaptype, swap_cnt;
;111:
;112:loop:	SWAPINIT(a, es);
ADDRLP4 52
CNSTU4 3
ASGNU4
ADDRLP4 56
CNSTU4 0
ASGNU4
ADDRFP4 0
INDIRP4
CVPU4 4
CVUI4 4
CVIU4 4
ADDRLP4 52
INDIRU4
BANDU4
ADDRLP4 56
INDIRU4
NEU4 $54
ADDRFP4 8
INDIRI4
CVIU4 4
ADDRLP4 52
INDIRU4
BANDU4
ADDRLP4 56
INDIRU4
EQU4 $52
LABELV $54
ADDRLP4 44
CNSTI4 2
ASGNI4
ADDRGP4 $53
JUMPV
LABELV $52
ADDRFP4 8
INDIRI4
CVIU4 4
CNSTU4 4
NEU4 $55
ADDRLP4 48
CNSTI4 0
ASGNI4
ADDRGP4 $56
JUMPV
LABELV $55
ADDRLP4 48
CNSTI4 1
ASGNI4
LABELV $56
ADDRLP4 44
ADDRLP4 48
INDIRI4
ASGNI4
LABELV $53
ADDRLP4 16
ADDRLP4 44
INDIRI4
ASGNI4
line 113
;113:	swap_cnt = 0;
ADDRLP4 28
CNSTI4 0
ASGNI4
line 114
;114:	if (n < 7) {
ADDRFP4 4
INDIRI4
CNSTI4 7
GEI4 $57
line 115
;115:		for (pm = (char *)a + es; pm < (char *)a + n * es; pm += es)
ADDRLP4 32
ADDRFP4 8
INDIRI4
ADDRFP4 0
INDIRP4
ADDP4
ASGNP4
ADDRGP4 $62
JUMPV
LABELV $59
line 116
;116:			for (pl = pm; pl > (char *)a && cmp(pl - es, pl) > 0;
ADDRLP4 0
ADDRLP4 32
INDIRP4
ASGNP4
ADDRGP4 $66
JUMPV
LABELV $63
line 118
;117:			     pl -= es)
;118:				swap(pl, pl - es);
ADDRLP4 16
INDIRI4
CNSTI4 0
NEI4 $67
ADDRLP4 60
ADDRLP4 0
INDIRP4
INDIRI4
ASGNI4
ADDRLP4 0
INDIRP4
ADDRLP4 0
INDIRP4
ADDRFP4 8
INDIRI4
SUBP4
INDIRI4
ASGNI4
ADDRLP4 0
INDIRP4
ADDRFP4 8
INDIRI4
SUBP4
ADDRLP4 60
INDIRI4
ASGNI4
ADDRGP4 $68
JUMPV
LABELV $67
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 64
ADDRFP4 8
INDIRI4
ASGNI4
ADDRLP4 0
INDIRP4
ADDRLP4 64
INDIRI4
SUBP4
ARGP4
ADDRLP4 64
INDIRI4
ARGI4
ADDRLP4 16
INDIRI4
ARGI4
ADDRGP4 swapfunc
CALLV
pop
LABELV $68
LABELV $64
line 117
ADDRLP4 0
ADDRLP4 0
INDIRP4
ADDRFP4 8
INDIRI4
SUBP4
ASGNP4
LABELV $66
line 116
ADDRLP4 0
INDIRP4
CVPU4 4
ADDRFP4 0
INDIRP4
CVPU4 4
LEU4 $69
ADDRLP4 0
INDIRP4
ADDRFP4 8
INDIRI4
SUBP4
ARGP4
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 72
ADDRFP4 12
INDIRP4
CALLI4
ASGNI4
ADDRLP4 72
INDIRI4
CNSTI4 0
GTI4 $63
LABELV $69
LABELV $60
line 115
ADDRLP4 32
ADDRFP4 8
INDIRI4
ADDRLP4 32
INDIRP4
ADDP4
ASGNP4
LABELV $62
ADDRLP4 32
INDIRP4
CVPU4 4
ADDRFP4 4
INDIRI4
ADDRFP4 8
INDIRI4
MULI4
ADDRFP4 0
INDIRP4
ADDP4
CVPU4 4
LTU4 $59
line 119
;119:		return;
ADDRGP4 $48
JUMPV
LABELV $57
line 121
;120:	}
;121:	pm = (char *)a + (n / 2) * es;
ADDRLP4 32
ADDRFP4 4
INDIRI4
CNSTI4 2
DIVI4
ADDRFP4 8
INDIRI4
MULI4
ADDRFP4 0
INDIRP4
ADDP4
ASGNP4
line 122
;122:	if (n > 7) {
ADDRFP4 4
INDIRI4
CNSTI4 7
LEI4 $70
line 123
;123:		pl = a;
ADDRLP4 0
ADDRFP4 0
INDIRP4
ASGNP4
line 124
;124:		pn = (char *)a + (n - 1) * es;
ADDRLP4 36
ADDRFP4 4
INDIRI4
CNSTI4 1
SUBI4
ADDRFP4 8
INDIRI4
MULI4
ADDRFP4 0
INDIRP4
ADDP4
ASGNP4
line 125
;125:		if (n > 40) {
ADDRFP4 4
INDIRI4
CNSTI4 40
LEI4 $72
line 126
;126:			d = (n / 8) * es;
ADDRLP4 40
ADDRFP4 4
INDIRI4
CNSTI4 8
DIVI4
ADDRFP4 8
INDIRI4
MULI4
ASGNI4
line 127
;127:			pl = med3(pl, pl + d, pl + 2 * d, cmp);
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 64
ADDRLP4 40
INDIRI4
ASGNI4
ADDRLP4 64
INDIRI4
ADDRLP4 0
INDIRP4
ADDP4
ARGP4
ADDRLP4 64
INDIRI4
CNSTI4 1
LSHI4
ADDRLP4 0
INDIRP4
ADDP4
ARGP4
ADDRFP4 12
INDIRP4
ARGP4
ADDRLP4 68
ADDRGP4 med3
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 68
INDIRP4
ASGNP4
line 128
;128:			pm = med3(pm - d, pm, pm + d, cmp);
ADDRLP4 76
ADDRLP4 40
INDIRI4
ASGNI4
ADDRLP4 32
INDIRP4
ADDRLP4 76
INDIRI4
SUBP4
ARGP4
ADDRLP4 32
INDIRP4
ARGP4
ADDRLP4 76
INDIRI4
ADDRLP4 32
INDIRP4
ADDP4
ARGP4
ADDRFP4 12
INDIRP4
ARGP4
ADDRLP4 80
ADDRGP4 med3
CALLP4
ASGNP4
ADDRLP4 32
ADDRLP4 80
INDIRP4
ASGNP4
line 129
;129:			pn = med3(pn - 2 * d, pn - d, pn, cmp);
ADDRLP4 88
ADDRLP4 40
INDIRI4
ASGNI4
ADDRLP4 36
INDIRP4
ADDRLP4 88
INDIRI4
CNSTI4 1
LSHI4
SUBP4
ARGP4
ADDRLP4 36
INDIRP4
ADDRLP4 88
INDIRI4
SUBP4
ARGP4
ADDRLP4 36
INDIRP4
ARGP4
ADDRFP4 12
INDIRP4
ARGP4
ADDRLP4 92
ADDRGP4 med3
CALLP4
ASGNP4
ADDRLP4 36
ADDRLP4 92
INDIRP4
ASGNP4
line 130
;130:		}
LABELV $72
line 131
;131:		pm = med3(pl, pm, pn, cmp);
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 32
INDIRP4
ARGP4
ADDRLP4 36
INDIRP4
ARGP4
ADDRFP4 12
INDIRP4
ARGP4
ADDRLP4 60
ADDRGP4 med3
CALLP4
ASGNP4
ADDRLP4 32
ADDRLP4 60
INDIRP4
ASGNP4
line 132
;132:	}
LABELV $70
line 133
;133:	swap(a, pm);
ADDRLP4 16
INDIRI4
CNSTI4 0
NEI4 $74
ADDRLP4 60
ADDRFP4 0
INDIRP4
INDIRI4
ASGNI4
ADDRFP4 0
INDIRP4
ADDRLP4 32
INDIRP4
INDIRI4
ASGNI4
ADDRLP4 32
INDIRP4
ADDRLP4 60
INDIRI4
ASGNI4
ADDRGP4 $75
JUMPV
LABELV $74
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 32
INDIRP4
ARGP4
ADDRFP4 8
INDIRI4
ARGI4
ADDRLP4 16
INDIRI4
ARGI4
ADDRGP4 swapfunc
CALLV
pop
LABELV $75
line 134
;134:	pa = pb = (char *)a + es;
ADDRLP4 60
ADDRFP4 8
INDIRI4
ADDRFP4 0
INDIRP4
ADDP4
ASGNP4
ADDRLP4 4
ADDRLP4 60
INDIRP4
ASGNP4
ADDRLP4 20
ADDRLP4 60
INDIRP4
ASGNP4
line 136
;135:
;136:	pc = pd = (char *)a + (n - 1) * es;
ADDRLP4 64
ADDRFP4 4
INDIRI4
CNSTI4 1
SUBI4
ADDRFP4 8
INDIRI4
MULI4
ADDRFP4 0
INDIRP4
ADDP4
ASGNP4
ADDRLP4 24
ADDRLP4 64
INDIRP4
ASGNP4
ADDRLP4 8
ADDRLP4 64
INDIRP4
ASGNP4
line 137
;137:	for (;;) {
ADDRGP4 $81
JUMPV
LABELV $80
line 138
;138:		while (pb <= pc && (r = cmp(pb, a)) <= 0) {
line 139
;139:			if (r == 0) {
ADDRLP4 12
INDIRI4
CNSTI4 0
NEI4 $83
line 140
;140:				swap_cnt = 1;
ADDRLP4 28
CNSTI4 1
ASGNI4
line 141
;141:				swap(pa, pb);
ADDRLP4 16
INDIRI4
CNSTI4 0
NEI4 $85
ADDRLP4 68
ADDRLP4 20
INDIRP4
INDIRI4
ASGNI4
ADDRLP4 20
INDIRP4
ADDRLP4 4
INDIRP4
INDIRI4
ASGNI4
ADDRLP4 4
INDIRP4
ADDRLP4 68
INDIRI4
ASGNI4
ADDRGP4 $86
JUMPV
LABELV $85
ADDRLP4 20
INDIRP4
ARGP4
ADDRLP4 4
INDIRP4
ARGP4
ADDRFP4 8
INDIRI4
ARGI4
ADDRLP4 16
INDIRI4
ARGI4
ADDRGP4 swapfunc
CALLV
pop
LABELV $86
line 142
;142:				pa += es;
ADDRLP4 20
ADDRFP4 8
INDIRI4
ADDRLP4 20
INDIRP4
ADDP4
ASGNP4
line 143
;143:			}
LABELV $83
line 144
;144:			pb += es;
ADDRLP4 4
ADDRFP4 8
INDIRI4
ADDRLP4 4
INDIRP4
ADDP4
ASGNP4
line 145
;145:		}
LABELV $81
line 138
ADDRLP4 4
INDIRP4
CVPU4 4
ADDRLP4 8
INDIRP4
CVPU4 4
GTU4 $87
ADDRLP4 4
INDIRP4
ARGP4
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 72
ADDRFP4 12
INDIRP4
CALLI4
ASGNI4
ADDRLP4 12
ADDRLP4 72
INDIRI4
ASGNI4
ADDRLP4 72
INDIRI4
CNSTI4 0
LEI4 $80
LABELV $87
ADDRGP4 $89
JUMPV
LABELV $88
line 146
;146:		while (pb <= pc && (r = cmp(pc, a)) >= 0) {
line 147
;147:			if (r == 0) {
ADDRLP4 12
INDIRI4
CNSTI4 0
NEI4 $91
line 148
;148:				swap_cnt = 1;
ADDRLP4 28
CNSTI4 1
ASGNI4
line 149
;149:				swap(pc, pd);
ADDRLP4 16
INDIRI4
CNSTI4 0
NEI4 $93
ADDRLP4 76
ADDRLP4 8
INDIRP4
INDIRI4
ASGNI4
ADDRLP4 8
INDIRP4
ADDRLP4 24
INDIRP4
INDIRI4
ASGNI4
ADDRLP4 24
INDIRP4
ADDRLP4 76
INDIRI4
ASGNI4
ADDRGP4 $94
JUMPV
LABELV $93
ADDRLP4 8
INDIRP4
ARGP4
ADDRLP4 24
INDIRP4
ARGP4
ADDRFP4 8
INDIRI4
ARGI4
ADDRLP4 16
INDIRI4
ARGI4
ADDRGP4 swapfunc
CALLV
pop
LABELV $94
line 150
;150:				pd -= es;
ADDRLP4 24
ADDRLP4 24
INDIRP4
ADDRFP4 8
INDIRI4
SUBP4
ASGNP4
line 151
;151:			}
LABELV $91
line 152
;152:			pc -= es;
ADDRLP4 8
ADDRLP4 8
INDIRP4
ADDRFP4 8
INDIRI4
SUBP4
ASGNP4
line 153
;153:		}
LABELV $89
line 146
ADDRLP4 4
INDIRP4
CVPU4 4
ADDRLP4 8
INDIRP4
CVPU4 4
GTU4 $95
ADDRLP4 8
INDIRP4
ARGP4
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 80
ADDRFP4 12
INDIRP4
CALLI4
ASGNI4
ADDRLP4 12
ADDRLP4 80
INDIRI4
ASGNI4
ADDRLP4 80
INDIRI4
CNSTI4 0
GEI4 $88
LABELV $95
line 154
;154:		if (pb > pc)
ADDRLP4 4
INDIRP4
CVPU4 4
ADDRLP4 8
INDIRP4
CVPU4 4
LEU4 $96
line 155
;155:			break;
ADDRGP4 $78
JUMPV
LABELV $96
line 156
;156:		swap(pb, pc);
ADDRLP4 16
INDIRI4
CNSTI4 0
NEI4 $98
ADDRLP4 84
ADDRLP4 4
INDIRP4
INDIRI4
ASGNI4
ADDRLP4 4
INDIRP4
ADDRLP4 8
INDIRP4
INDIRI4
ASGNI4
ADDRLP4 8
INDIRP4
ADDRLP4 84
INDIRI4
ASGNI4
ADDRGP4 $99
JUMPV
LABELV $98
ADDRLP4 4
INDIRP4
ARGP4
ADDRLP4 8
INDIRP4
ARGP4
ADDRFP4 8
INDIRI4
ARGI4
ADDRLP4 16
INDIRI4
ARGI4
ADDRGP4 swapfunc
CALLV
pop
LABELV $99
line 157
;157:		swap_cnt = 1;
ADDRLP4 28
CNSTI4 1
ASGNI4
line 158
;158:		pb += es;
ADDRLP4 4
ADDRFP4 8
INDIRI4
ADDRLP4 4
INDIRP4
ADDP4
ASGNP4
line 159
;159:		pc -= es;
ADDRLP4 8
ADDRLP4 8
INDIRP4
ADDRFP4 8
INDIRI4
SUBP4
ASGNP4
line 160
;160:	}
line 137
ADDRGP4 $81
JUMPV
LABELV $78
line 161
;161:	if (swap_cnt == 0) {  /* Switch to insertion sort */
ADDRLP4 28
INDIRI4
CNSTI4 0
NEI4 $100
line 162
;162:		for (pm = (char *)a + es; pm < (char *)a + n * es; pm += es)
ADDRLP4 32
ADDRFP4 8
INDIRI4
ADDRFP4 0
INDIRP4
ADDP4
ASGNP4
ADDRGP4 $105
JUMPV
LABELV $102
line 163
;163:			for (pl = pm; pl > (char *)a && cmp(pl - es, pl) > 0;
ADDRLP4 0
ADDRLP4 32
INDIRP4
ASGNP4
ADDRGP4 $109
JUMPV
LABELV $106
line 165
;164:			     pl -= es)
;165:				swap(pl, pl - es);
ADDRLP4 16
INDIRI4
CNSTI4 0
NEI4 $110
ADDRLP4 68
ADDRLP4 0
INDIRP4
INDIRI4
ASGNI4
ADDRLP4 0
INDIRP4
ADDRLP4 0
INDIRP4
ADDRFP4 8
INDIRI4
SUBP4
INDIRI4
ASGNI4
ADDRLP4 0
INDIRP4
ADDRFP4 8
INDIRI4
SUBP4
ADDRLP4 68
INDIRI4
ASGNI4
ADDRGP4 $111
JUMPV
LABELV $110
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 72
ADDRFP4 8
INDIRI4
ASGNI4
ADDRLP4 0
INDIRP4
ADDRLP4 72
INDIRI4
SUBP4
ARGP4
ADDRLP4 72
INDIRI4
ARGI4
ADDRLP4 16
INDIRI4
ARGI4
ADDRGP4 swapfunc
CALLV
pop
LABELV $111
LABELV $107
line 164
ADDRLP4 0
ADDRLP4 0
INDIRP4
ADDRFP4 8
INDIRI4
SUBP4
ASGNP4
LABELV $109
line 163
ADDRLP4 0
INDIRP4
CVPU4 4
ADDRFP4 0
INDIRP4
CVPU4 4
LEU4 $112
ADDRLP4 0
INDIRP4
ADDRFP4 8
INDIRI4
SUBP4
ARGP4
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 80
ADDRFP4 12
INDIRP4
CALLI4
ASGNI4
ADDRLP4 80
INDIRI4
CNSTI4 0
GTI4 $106
LABELV $112
LABELV $103
line 162
ADDRLP4 32
ADDRFP4 8
INDIRI4
ADDRLP4 32
INDIRP4
ADDP4
ASGNP4
LABELV $105
ADDRLP4 32
INDIRP4
CVPU4 4
ADDRFP4 4
INDIRI4
ADDRFP4 8
INDIRI4
MULI4
ADDRFP4 0
INDIRP4
ADDP4
CVPU4 4
LTU4 $102
line 166
;166:		return;
ADDRGP4 $48
JUMPV
LABELV $100
line 169
;167:	}
;168:
;169:	pn = (char *)a + n * es;
ADDRLP4 36
ADDRFP4 4
INDIRI4
ADDRFP4 8
INDIRI4
MULI4
ADDRFP4 0
INDIRP4
ADDP4
ASGNP4
line 170
;170:	r = min(pa - (char *)a, pb - pa);
ADDRLP4 72
ADDRLP4 20
INDIRP4
CVPU4 4
ASGNU4
ADDRLP4 72
INDIRU4
ADDRFP4 0
INDIRP4
CVPU4 4
SUBU4
CVUI4 4
ADDRLP4 4
INDIRP4
CVPU4 4
ADDRLP4 72
INDIRU4
SUBU4
CVUI4 4
GEI4 $114
ADDRLP4 68
ADDRLP4 20
INDIRP4
CVPU4 4
ADDRFP4 0
INDIRP4
CVPU4 4
SUBU4
CVUI4 4
ASGNI4
ADDRGP4 $115
JUMPV
LABELV $114
ADDRLP4 68
ADDRLP4 4
INDIRP4
CVPU4 4
ADDRLP4 20
INDIRP4
CVPU4 4
SUBU4
CVUI4 4
ASGNI4
LABELV $115
ADDRLP4 12
ADDRLP4 68
INDIRI4
ASGNI4
line 171
;171:	vecswap(a, pb - r, r);
ADDRLP4 12
INDIRI4
CNSTI4 0
LEI4 $116
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 4
INDIRP4
ADDRLP4 12
INDIRI4
SUBP4
ARGP4
ADDRLP4 12
INDIRI4
ARGI4
ADDRLP4 16
INDIRI4
ARGI4
ADDRGP4 swapfunc
CALLV
pop
LABELV $116
line 172
;172:	r = min(pd - pc, pn - pd - es);
ADDRLP4 84
ADDRLP4 24
INDIRP4
CVPU4 4
ASGNU4
ADDRLP4 84
INDIRU4
ADDRLP4 8
INDIRP4
CVPU4 4
SUBU4
CVUI4 4
ADDRLP4 36
INDIRP4
CVPU4 4
ADDRLP4 84
INDIRU4
SUBU4
CVUI4 4
ADDRFP4 8
INDIRI4
SUBI4
GEI4 $119
ADDRLP4 80
ADDRLP4 24
INDIRP4
CVPU4 4
ADDRLP4 8
INDIRP4
CVPU4 4
SUBU4
CVUI4 4
ASGNI4
ADDRGP4 $120
JUMPV
LABELV $119
ADDRLP4 80
ADDRLP4 36
INDIRP4
CVPU4 4
ADDRLP4 24
INDIRP4
CVPU4 4
SUBU4
CVUI4 4
ADDRFP4 8
INDIRI4
SUBI4
ASGNI4
LABELV $120
ADDRLP4 12
ADDRLP4 80
INDIRI4
ASGNI4
line 173
;173:	vecswap(pb, pn - r, r);
ADDRLP4 12
INDIRI4
CNSTI4 0
LEI4 $121
ADDRLP4 4
INDIRP4
ARGP4
ADDRLP4 36
INDIRP4
ADDRLP4 12
INDIRI4
SUBP4
ARGP4
ADDRLP4 12
INDIRI4
ARGI4
ADDRLP4 16
INDIRI4
ARGI4
ADDRGP4 swapfunc
CALLV
pop
LABELV $121
line 174
;174:	if ((r = pb - pa) > es)
ADDRLP4 92
ADDRLP4 4
INDIRP4
CVPU4 4
ADDRLP4 20
INDIRP4
CVPU4 4
SUBU4
CVUI4 4
ASGNI4
ADDRLP4 12
ADDRLP4 92
INDIRI4
ASGNI4
ADDRLP4 92
INDIRI4
ADDRFP4 8
INDIRI4
LEI4 $123
line 175
;175:		qsort(a, r / es, es, cmp);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 96
ADDRFP4 8
INDIRI4
ASGNI4
ADDRLP4 12
INDIRI4
ADDRLP4 96
INDIRI4
DIVI4
ARGI4
ADDRLP4 96
INDIRI4
ARGI4
ADDRFP4 12
INDIRP4
ARGP4
ADDRGP4 qsort
CALLV
pop
LABELV $123
line 176
;176:	if ((r = pd - pc) > es) {
ADDRLP4 100
ADDRLP4 24
INDIRP4
CVPU4 4
ADDRLP4 8
INDIRP4
CVPU4 4
SUBU4
CVUI4 4
ASGNI4
ADDRLP4 12
ADDRLP4 100
INDIRI4
ASGNI4
ADDRLP4 100
INDIRI4
ADDRFP4 8
INDIRI4
LEI4 $125
line 178
;177:		/* Iterate rather than recurse to save stack space */
;178:		a = pn - r;
ADDRFP4 0
ADDRLP4 36
INDIRP4
ADDRLP4 12
INDIRI4
SUBP4
ASGNP4
line 179
;179:		n = r / es;
ADDRFP4 4
ADDRLP4 12
INDIRI4
ADDRFP4 8
INDIRI4
DIVI4
ASGNI4
line 180
;180:		goto loop;
ADDRGP4 $49
JUMPV
LABELV $125
line 183
;181:	}
;182:/*		qsort(pn - r, r / es, es, cmp);*/
;183:}
LABELV $48
endproc qsort 104 16
export strlen
proc strlen 4 0
line 187
;184:
;185://==================================================================================
;186:
;187:size_t strlen( const char *string ) {
line 190
;188:	const char	*s;
;189:
;190:	s = string;
ADDRLP4 0
ADDRFP4 0
INDIRP4
ASGNP4
ADDRGP4 $129
JUMPV
LABELV $128
line 191
;191:	while ( *s ) {
line 192
;192:		s++;
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 193
;193:	}
LABELV $129
line 191
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $128
line 194
;194:	return s - string;
ADDRLP4 0
INDIRP4
CVPU4 4
ADDRFP4 0
INDIRP4
CVPU4 4
SUBU4
CVUI4 4
RETI4
LABELV $127
endproc strlen 4 0
export strlenru
proc strlenru 32 4
line 197
;195:}
;196:
;197:int strlenru( const char *string ) {
line 204
;198:	int		result;
;199:	int		n;
;200:	int 	i;
;201:	int		rucount;
;202:	const char	*s;
;203:
;204:	s = string;
ADDRLP4 4
ADDRFP4 0
INDIRP4
ASGNP4
line 205
;205:	result = strlen(s);
ADDRLP4 4
INDIRP4
ARGP4
ADDRLP4 20
ADDRGP4 strlen
CALLI4
ASGNI4
ADDRLP4 16
ADDRLP4 20
INDIRI4
ASGNI4
line 207
;206:	
;207:	n = strlen(s);
ADDRLP4 4
INDIRP4
ARGP4
ADDRLP4 24
ADDRGP4 strlen
CALLI4
ASGNI4
ADDRLP4 8
ADDRLP4 24
INDIRI4
ASGNI4
line 208
;208:	rucount = 0;
ADDRLP4 12
CNSTI4 0
ASGNI4
line 210
;209:	
;210:	for(i=0; i<n; i++){
ADDRLP4 0
CNSTI4 0
ASGNI4
ADDRGP4 $135
JUMPV
LABELV $132
line 211
;211:	if(s[i] >= -64 && s[i] <= -1){	//ебаный unicode
ADDRLP4 28
ADDRLP4 0
INDIRI4
ADDRLP4 4
INDIRP4
ADDP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 28
INDIRI4
CNSTI4 -64
LTI4 $136
ADDRLP4 28
INDIRI4
CNSTI4 -1
GTI4 $136
line 212
;212:	rucount += 1;
ADDRLP4 12
ADDRLP4 12
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
line 213
;213:	}
LABELV $136
line 214
;214:	}
LABELV $133
line 210
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
LABELV $135
ADDRLP4 0
INDIRI4
ADDRLP4 8
INDIRI4
LTI4 $132
line 215
;215:	if(rucount){
ADDRLP4 12
INDIRI4
CNSTI4 0
EQI4 $138
line 216
;216:	return result * 0.5;
CNSTF4 1056964608
ADDRLP4 16
INDIRI4
CVIF4 4
MULF4
CVFI4 4
RETI4
ADDRGP4 $131
JUMPV
LABELV $138
line 217
;217:	} else {
line 218
;218:	return result;	
ADDRLP4 16
INDIRI4
RETI4
LABELV $131
endproc strlenru 32 4
export ifstrlenru
proc ifstrlenru 32 4
line 222
;219:	}
;220:}
;221:
;222:int ifstrlenru( const char *string ) {
line 229
;223:	int		result;
;224:	int		n;
;225:	int 	i;
;226:	int		rucount;
;227:	const char	*s;
;228:
;229:	s = string;
ADDRLP4 4
ADDRFP4 0
INDIRP4
ASGNP4
line 230
;230:	result = strlen(s);
ADDRLP4 4
INDIRP4
ARGP4
ADDRLP4 20
ADDRGP4 strlen
CALLI4
ASGNI4
ADDRLP4 16
ADDRLP4 20
INDIRI4
ASGNI4
line 232
;231:	
;232:	n = strlen(s);
ADDRLP4 4
INDIRP4
ARGP4
ADDRLP4 24
ADDRGP4 strlen
CALLI4
ASGNI4
ADDRLP4 8
ADDRLP4 24
INDIRI4
ASGNI4
line 233
;233:	rucount = 0;
ADDRLP4 12
CNSTI4 0
ASGNI4
line 235
;234:	
;235:	for(i=0; i<n; i++){
ADDRLP4 0
CNSTI4 0
ASGNI4
ADDRGP4 $144
JUMPV
LABELV $141
line 236
;236:	if(s[i] >= -64 && s[i] <= -1){	//ебаный unicode
ADDRLP4 28
ADDRLP4 0
INDIRI4
ADDRLP4 4
INDIRP4
ADDP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 28
INDIRI4
CNSTI4 -64
LTI4 $145
ADDRLP4 28
INDIRI4
CNSTI4 -1
GTI4 $145
line 237
;237:	rucount += 1;
ADDRLP4 12
ADDRLP4 12
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
line 238
;238:	}
LABELV $145
line 239
;239:	}
LABELV $142
line 235
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
LABELV $144
ADDRLP4 0
INDIRI4
ADDRLP4 8
INDIRI4
LTI4 $141
line 240
;240:	return rucount;
ADDRLP4 12
INDIRI4
RETI4
LABELV $140
endproc ifstrlenru 32 4
export strcat
proc strcat 16 0
line 244
;241:}
;242:
;243:
;244:char *strcat( char *strDestination, const char *strSource ) {
line 247
;245:	char	*s;
;246:
;247:	s = strDestination;
ADDRLP4 0
ADDRFP4 0
INDIRP4
ASGNP4
ADDRGP4 $149
JUMPV
LABELV $148
line 248
;248:	while ( *s ) {
line 249
;249:		s++;
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 250
;250:	}
LABELV $149
line 248
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $148
ADDRGP4 $152
JUMPV
LABELV $151
line 251
;251:	while ( *strSource ) {
line 252
;252:		*s++ = *strSource++;
ADDRLP4 4
ADDRLP4 0
INDIRP4
ASGNP4
ADDRLP4 12
CNSTI4 1
ASGNI4
ADDRLP4 0
ADDRLP4 4
INDIRP4
ADDRLP4 12
INDIRI4
ADDP4
ASGNP4
ADDRLP4 8
ADDRFP4 4
INDIRP4
ASGNP4
ADDRFP4 4
ADDRLP4 8
INDIRP4
ADDRLP4 12
INDIRI4
ADDP4
ASGNP4
ADDRLP4 4
INDIRP4
ADDRLP4 8
INDIRP4
INDIRI1
ASGNI1
line 253
;253:	}
LABELV $152
line 251
ADDRFP4 4
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $151
line 254
;254:	*s = 0;
ADDRLP4 0
INDIRP4
CNSTI1 0
ASGNI1
line 255
;255:	return strDestination;
ADDRFP4 0
INDIRP4
RETP4
LABELV $147
endproc strcat 16 0
export strcpy
proc strcpy 16 0
line 258
;256:}
;257:
;258:char *strcpy( char *strDestination, const char *strSource ) {
line 261
;259:	char *s;
;260:
;261:	s = strDestination;
ADDRLP4 0
ADDRFP4 0
INDIRP4
ASGNP4
ADDRGP4 $156
JUMPV
LABELV $155
line 262
;262:	while ( *strSource ) {
line 263
;263:		*s++ = *strSource++;
ADDRLP4 4
ADDRLP4 0
INDIRP4
ASGNP4
ADDRLP4 12
CNSTI4 1
ASGNI4
ADDRLP4 0
ADDRLP4 4
INDIRP4
ADDRLP4 12
INDIRI4
ADDP4
ASGNP4
ADDRLP4 8
ADDRFP4 4
INDIRP4
ASGNP4
ADDRFP4 4
ADDRLP4 8
INDIRP4
ADDRLP4 12
INDIRI4
ADDP4
ASGNP4
ADDRLP4 4
INDIRP4
ADDRLP4 8
INDIRP4
INDIRI1
ASGNI1
line 264
;264:	}
LABELV $156
line 262
ADDRFP4 4
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $155
line 265
;265:	*s = 0;
ADDRLP4 0
INDIRP4
CNSTI1 0
ASGNI1
line 266
;266:	return strDestination;
ADDRFP4 0
INDIRP4
RETP4
LABELV $154
endproc strcpy 16 0
export strcmp
proc strcmp 12 0
line 270
;267:}
;268:
;269:
;270:int strcmp( const char *string1, const char *string2 ) {
ADDRGP4 $160
JUMPV
LABELV $159
line 271
;271:	while ( *string1 == *string2 && *string1 && *string2 ) {
line 272
;272:		string1++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 273
;273:		string2++;
ADDRFP4 4
ADDRFP4 4
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 274
;274:	}
LABELV $160
line 271
ADDRLP4 0
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 4
ADDRFP4 4
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 0
INDIRI4
ADDRLP4 4
INDIRI4
NEI4 $163
ADDRLP4 8
CNSTI4 0
ASGNI4
ADDRLP4 0
INDIRI4
ADDRLP4 8
INDIRI4
EQI4 $163
ADDRLP4 4
INDIRI4
ADDRLP4 8
INDIRI4
NEI4 $159
LABELV $163
line 275
;275:	return *string1 - *string2;
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ADDRFP4 4
INDIRP4
INDIRI1
CVII4 1
SUBI4
RETI4
LABELV $158
endproc strcmp 12 0
export strcasecmp
proc strcasecmp 20 4
line 278
;276:}
;277:
;278:int strcasecmp(const char *string1, const char *string2) {
ADDRGP4 $166
JUMPV
LABELV $165
line 279
;279:    while (tolower((unsigned char)*string1) == tolower((unsigned char)*string2) && *string1 && *string2) {
line 280
;280:        string1++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 281
;281:        string2++;
ADDRFP4 4
ADDRFP4 4
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 282
;282:    }
LABELV $166
line 279
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CVIU4 4
CVUU1 4
CVUI4 1
ARGI4
ADDRLP4 0
ADDRGP4 tolower
CALLI4
ASGNI4
ADDRFP4 4
INDIRP4
INDIRI1
CVII4 1
CVIU4 4
CVUU1 4
CVUI4 1
ARGI4
ADDRLP4 4
ADDRGP4 tolower
CALLI4
ASGNI4
ADDRLP4 0
INDIRI4
ADDRLP4 4
INDIRI4
NEI4 $169
ADDRLP4 8
CNSTI4 0
ASGNI4
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ADDRLP4 8
INDIRI4
EQI4 $169
ADDRFP4 4
INDIRP4
INDIRI1
CVII4 1
ADDRLP4 8
INDIRI4
NEI4 $165
LABELV $169
line 283
;283:    return tolower((unsigned char)*string1) - tolower((unsigned char)*string2);
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CVIU4 4
CVUU1 4
CVUI4 1
ARGI4
ADDRLP4 12
ADDRGP4 tolower
CALLI4
ASGNI4
ADDRFP4 4
INDIRP4
INDIRI1
CVII4 1
CVIU4 4
CVUU1 4
CVUI4 1
ARGI4
ADDRLP4 16
ADDRGP4 tolower
CALLI4
ASGNI4
ADDRLP4 12
INDIRI4
ADDRLP4 16
INDIRI4
SUBI4
RETI4
LABELV $164
endproc strcasecmp 20 4
export strchr
proc strchr 0 0
line 286
;284:}
;285:
;286:char *strchr( const char *string, int c ) {
ADDRGP4 $172
JUMPV
LABELV $171
line 287
;287:	while ( *string ) {
line 288
;288:		if ( *string == c ) {
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ADDRFP4 4
INDIRI4
NEI4 $174
line 289
;289:			return ( char * )string;
ADDRFP4 0
INDIRP4
RETP4
ADDRGP4 $170
JUMPV
LABELV $174
line 291
;290:		}
;291:		string++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 292
;292:	}
LABELV $172
line 287
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $171
line 293
;293:	if(c)
ADDRFP4 4
INDIRI4
CNSTI4 0
EQI4 $176
line 294
;294:                return NULL;
CNSTP4 0
RETP4
ADDRGP4 $170
JUMPV
LABELV $176
line 296
;295:        else
;296:                return (char*) string;
ADDRFP4 0
INDIRP4
RETP4
LABELV $170
endproc strchr 0 0
export strrchr
proc strrchr 4 0
line 300
;297:}
;298:
;299:char *strrchr(const char *string, int c)
;300:{
line 301
;301:	const char *found = NULL;
ADDRLP4 0
CNSTP4 0
ASGNP4
ADDRGP4 $180
JUMPV
LABELV $179
line 304
;302:	
;303:	while(*string)
;304:	{
line 305
;305:		if(*string == c)
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ADDRFP4 4
INDIRI4
NEI4 $182
line 306
;306:			found = string;
ADDRLP4 0
ADDRFP4 0
INDIRP4
ASGNP4
LABELV $182
line 308
;307:
;308:		string++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 309
;309:	}
LABELV $180
line 303
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $179
line 311
;310:	
;311:	if(c)
ADDRFP4 4
INDIRI4
CNSTI4 0
EQI4 $184
line 312
;312:		return (char *) found;
ADDRLP4 0
INDIRP4
RETP4
ADDRGP4 $178
JUMPV
LABELV $184
line 314
;313:	else
;314:		return (char *) string;
ADDRFP4 0
INDIRP4
RETP4
LABELV $178
endproc strrchr 4 0
export strstr
proc strstr 8 0
line 317
;315:}
;316:
;317:char *strstr( const char *string, const char *strCharSet ) {
ADDRGP4 $188
JUMPV
LABELV $187
line 318
;318:	while ( *string ) {
line 321
;319:		int		i;
;320:
;321:		for ( i = 0 ; strCharSet[i] ; i++ ) {
ADDRLP4 0
CNSTI4 0
ASGNI4
ADDRGP4 $193
JUMPV
LABELV $190
line 322
;322:			if ( string[i] != strCharSet[i] ) {
ADDRLP4 0
INDIRI4
ADDRFP4 0
INDIRP4
ADDP4
INDIRI1
CVII4 1
ADDRLP4 0
INDIRI4
ADDRFP4 4
INDIRP4
ADDP4
INDIRI1
CVII4 1
EQI4 $194
line 323
;323:				break;
ADDRGP4 $192
JUMPV
LABELV $194
line 325
;324:			}
;325:		}
LABELV $191
line 321
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
LABELV $193
ADDRLP4 0
INDIRI4
ADDRFP4 4
INDIRP4
ADDP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $190
LABELV $192
line 326
;326:		if ( !strCharSet[i] ) {
ADDRLP4 0
INDIRI4
ADDRFP4 4
INDIRP4
ADDP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $196
line 327
;327:			return (char *)string;
ADDRFP4 0
INDIRP4
RETP4
ADDRGP4 $186
JUMPV
LABELV $196
line 329
;328:		}
;329:		string++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 330
;330:	}
LABELV $188
line 318
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $187
line 331
;331:	return (char *)0;
CNSTP4 0
RETP4
LABELV $186
endproc strstr 8 0
export tolower
proc tolower 4 0
line 334
;332:}
;333:
;334:int tolower( int c ) {
line 335
;335:	if ( c >= 'A' && c <= 'Z' ) {
ADDRLP4 0
ADDRFP4 0
INDIRI4
ASGNI4
ADDRLP4 0
INDIRI4
CNSTI4 65
LTI4 $199
ADDRLP4 0
INDIRI4
CNSTI4 90
GTI4 $199
line 336
;336:		c += 'a' - 'A';
ADDRFP4 0
ADDRFP4 0
INDIRI4
CNSTI4 32
ADDI4
ASGNI4
line 337
;337:	}
LABELV $199
line 338
;338:	return c;
ADDRFP4 0
INDIRI4
RETI4
LABELV $198
endproc tolower 4 0
export toupper
proc toupper 4 0
line 342
;339:}
;340:
;341:
;342:int toupper( int c ) {
line 343
;343:	if ( c >= 'a' && c <= 'z' ) {
ADDRLP4 0
ADDRFP4 0
INDIRI4
ASGNI4
ADDRLP4 0
INDIRI4
CNSTI4 97
LTI4 $202
ADDRLP4 0
INDIRI4
CNSTI4 122
GTI4 $202
line 344
;344:		c += 'A' - 'a';
ADDRFP4 0
ADDRFP4 0
INDIRI4
CNSTI4 -32
ADDI4
ASGNI4
line 345
;345:	}
LABELV $202
line 346
;346:	return c;
ADDRFP4 0
INDIRI4
RETI4
LABELV $201
endproc toupper 4 0
export memmove
proc memmove 8 0
line 349
;347:}
;348:
;349:void *memmove( void *dest, const void *src, size_t count ) {
line 352
;350:	int		i;
;351:
;352:	if ( dest > src ) {
ADDRFP4 0
INDIRP4
CVPU4 4
ADDRFP4 4
INDIRP4
CVPU4 4
LEU4 $205
line 353
;353:		for ( i = count-1 ; i >= 0 ; i-- ) {
ADDRLP4 0
ADDRFP4 8
INDIRI4
CNSTI4 1
SUBI4
ASGNI4
ADDRGP4 $210
JUMPV
LABELV $207
line 354
;354:			((char *)dest)[i] = ((char *)src)[i];
ADDRLP4 0
INDIRI4
ADDRFP4 0
INDIRP4
ADDP4
ADDRLP4 0
INDIRI4
ADDRFP4 4
INDIRP4
ADDP4
INDIRI1
ASGNI1
line 355
;355:		}
LABELV $208
line 353
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
SUBI4
ASGNI4
LABELV $210
ADDRLP4 0
INDIRI4
CNSTI4 0
GEI4 $207
line 356
;356:	} else {
ADDRGP4 $206
JUMPV
LABELV $205
line 357
;357:		for ( i = 0 ; i < count ; i++ ) {
ADDRLP4 0
CNSTI4 0
ASGNI4
ADDRGP4 $214
JUMPV
LABELV $211
line 358
;358:			((char *)dest)[i] = ((char *)src)[i];
ADDRLP4 0
INDIRI4
ADDRFP4 0
INDIRP4
ADDP4
ADDRLP4 0
INDIRI4
ADDRFP4 4
INDIRP4
ADDP4
INDIRI1
ASGNI1
line 359
;359:		}
LABELV $212
line 357
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
LABELV $214
ADDRLP4 0
INDIRI4
ADDRFP4 8
INDIRI4
LTI4 $211
line 360
;360:	}
LABELV $206
line 361
;361:	return dest;
ADDRFP4 0
INDIRP4
RETP4
LABELV $204
endproc memmove 8 0
export tan
proc tan 8 4
line 816
;362:}
;363:
;364:
;365:#if 0
;366:
;367:double floor( double x ) {
;368:	return (int)(x + 0x40000000) - 0x40000000;
;369:}
;370:
;371:void *memset( void *dest, int c, size_t count ) {
;372:	while ( count-- ) {
;373:		((char *)dest)[count] = c;
;374:	}
;375:	return dest;
;376:}
;377:
;378:void *memcpy( void *dest, const void *src, size_t count ) {
;379:	while ( count-- ) {
;380:		((char *)dest)[count] = ((char *)src)[count];
;381:	}
;382:	return dest;
;383:}
;384:
;385:char *strncpy( char *strDest, const char *strSource, size_t count ) {
;386:	char	*s;
;387:
;388:	s = strDest;
;389:	while ( *strSource && count ) {
;390:		*s++ = *strSource++;
;391:		count--;
;392:	}
;393:	while ( count-- ) {
;394:		*s++ = 0;
;395:	}
;396:	return strDest;
;397:}
;398:
;399:double sqrt( double x ) {
;400:	float	y;
;401:	float	delta;
;402:	float	maxError;
;403:
;404:	if ( x <= 0 ) {
;405:		return 0;
;406:	}
;407:
;408:	// initial guess
;409:	y = x / 2;
;410:
;411:	// refine
;412:	maxError = x * 0.001;
;413:
;414:	do {
;415:		delta = ( y * y ) - x;
;416:		y -= delta / ( 2 * y );
;417:	} while ( delta > maxError || delta < -maxError );
;418:
;419:	return y;
;420:}
;421:
;422:
;423:float sintable[1024] = {
;424:0.000000,0.001534,0.003068,0.004602,0.006136,0.007670,0.009204,0.010738,
;425:0.012272,0.013805,0.015339,0.016873,0.018407,0.019940,0.021474,0.023008,
;426:0.024541,0.026075,0.027608,0.029142,0.030675,0.032208,0.033741,0.035274,
;427:0.036807,0.038340,0.039873,0.041406,0.042938,0.044471,0.046003,0.047535,
;428:0.049068,0.050600,0.052132,0.053664,0.055195,0.056727,0.058258,0.059790,
;429:0.061321,0.062852,0.064383,0.065913,0.067444,0.068974,0.070505,0.072035,
;430:0.073565,0.075094,0.076624,0.078153,0.079682,0.081211,0.082740,0.084269,
;431:0.085797,0.087326,0.088854,0.090381,0.091909,0.093436,0.094963,0.096490,
;432:0.098017,0.099544,0.101070,0.102596,0.104122,0.105647,0.107172,0.108697,
;433:0.110222,0.111747,0.113271,0.114795,0.116319,0.117842,0.119365,0.120888,
;434:0.122411,0.123933,0.125455,0.126977,0.128498,0.130019,0.131540,0.133061,
;435:0.134581,0.136101,0.137620,0.139139,0.140658,0.142177,0.143695,0.145213,
;436:0.146730,0.148248,0.149765,0.151281,0.152797,0.154313,0.155828,0.157343,
;437:0.158858,0.160372,0.161886,0.163400,0.164913,0.166426,0.167938,0.169450,
;438:0.170962,0.172473,0.173984,0.175494,0.177004,0.178514,0.180023,0.181532,
;439:0.183040,0.184548,0.186055,0.187562,0.189069,0.190575,0.192080,0.193586,
;440:0.195090,0.196595,0.198098,0.199602,0.201105,0.202607,0.204109,0.205610,
;441:0.207111,0.208612,0.210112,0.211611,0.213110,0.214609,0.216107,0.217604,
;442:0.219101,0.220598,0.222094,0.223589,0.225084,0.226578,0.228072,0.229565,
;443:0.231058,0.232550,0.234042,0.235533,0.237024,0.238514,0.240003,0.241492,
;444:0.242980,0.244468,0.245955,0.247442,0.248928,0.250413,0.251898,0.253382,
;445:0.254866,0.256349,0.257831,0.259313,0.260794,0.262275,0.263755,0.265234,
;446:0.266713,0.268191,0.269668,0.271145,0.272621,0.274097,0.275572,0.277046,
;447:0.278520,0.279993,0.281465,0.282937,0.284408,0.285878,0.287347,0.288816,
;448:0.290285,0.291752,0.293219,0.294685,0.296151,0.297616,0.299080,0.300543,
;449:0.302006,0.303468,0.304929,0.306390,0.307850,0.309309,0.310767,0.312225,
;450:0.313682,0.315138,0.316593,0.318048,0.319502,0.320955,0.322408,0.323859,
;451:0.325310,0.326760,0.328210,0.329658,0.331106,0.332553,0.334000,0.335445,
;452:0.336890,0.338334,0.339777,0.341219,0.342661,0.344101,0.345541,0.346980,
;453:0.348419,0.349856,0.351293,0.352729,0.354164,0.355598,0.357031,0.358463,
;454:0.359895,0.361326,0.362756,0.364185,0.365613,0.367040,0.368467,0.369892,
;455:0.371317,0.372741,0.374164,0.375586,0.377007,0.378428,0.379847,0.381266,
;456:0.382683,0.384100,0.385516,0.386931,0.388345,0.389758,0.391170,0.392582,
;457:0.393992,0.395401,0.396810,0.398218,0.399624,0.401030,0.402435,0.403838,
;458:0.405241,0.406643,0.408044,0.409444,0.410843,0.412241,0.413638,0.415034,
;459:0.416430,0.417824,0.419217,0.420609,0.422000,0.423390,0.424780,0.426168,
;460:0.427555,0.428941,0.430326,0.431711,0.433094,0.434476,0.435857,0.437237,
;461:0.438616,0.439994,0.441371,0.442747,0.444122,0.445496,0.446869,0.448241,
;462:0.449611,0.450981,0.452350,0.453717,0.455084,0.456449,0.457813,0.459177,
;463:0.460539,0.461900,0.463260,0.464619,0.465976,0.467333,0.468689,0.470043,
;464:0.471397,0.472749,0.474100,0.475450,0.476799,0.478147,0.479494,0.480839,
;465:0.482184,0.483527,0.484869,0.486210,0.487550,0.488889,0.490226,0.491563,
;466:0.492898,0.494232,0.495565,0.496897,0.498228,0.499557,0.500885,0.502212,
;467:0.503538,0.504863,0.506187,0.507509,0.508830,0.510150,0.511469,0.512786,
;468:0.514103,0.515418,0.516732,0.518045,0.519356,0.520666,0.521975,0.523283,
;469:0.524590,0.525895,0.527199,0.528502,0.529804,0.531104,0.532403,0.533701,
;470:0.534998,0.536293,0.537587,0.538880,0.540171,0.541462,0.542751,0.544039,
;471:0.545325,0.546610,0.547894,0.549177,0.550458,0.551738,0.553017,0.554294,
;472:0.555570,0.556845,0.558119,0.559391,0.560662,0.561931,0.563199,0.564466,
;473:0.565732,0.566996,0.568259,0.569521,0.570781,0.572040,0.573297,0.574553,
;474:0.575808,0.577062,0.578314,0.579565,0.580814,0.582062,0.583309,0.584554,
;475:0.585798,0.587040,0.588282,0.589521,0.590760,0.591997,0.593232,0.594466,
;476:0.595699,0.596931,0.598161,0.599389,0.600616,0.601842,0.603067,0.604290,
;477:0.605511,0.606731,0.607950,0.609167,0.610383,0.611597,0.612810,0.614022,
;478:0.615232,0.616440,0.617647,0.618853,0.620057,0.621260,0.622461,0.623661,
;479:0.624859,0.626056,0.627252,0.628446,0.629638,0.630829,0.632019,0.633207,
;480:0.634393,0.635578,0.636762,0.637944,0.639124,0.640303,0.641481,0.642657,
;481:0.643832,0.645005,0.646176,0.647346,0.648514,0.649681,0.650847,0.652011,
;482:0.653173,0.654334,0.655493,0.656651,0.657807,0.658961,0.660114,0.661266,
;483:0.662416,0.663564,0.664711,0.665856,0.667000,0.668142,0.669283,0.670422,
;484:0.671559,0.672695,0.673829,0.674962,0.676093,0.677222,0.678350,0.679476,
;485:0.680601,0.681724,0.682846,0.683965,0.685084,0.686200,0.687315,0.688429,
;486:0.689541,0.690651,0.691759,0.692866,0.693971,0.695075,0.696177,0.697278,
;487:0.698376,0.699473,0.700569,0.701663,0.702755,0.703845,0.704934,0.706021,
;488:0.707107,0.708191,0.709273,0.710353,0.711432,0.712509,0.713585,0.714659,
;489:0.715731,0.716801,0.717870,0.718937,0.720003,0.721066,0.722128,0.723188,
;490:0.724247,0.725304,0.726359,0.727413,0.728464,0.729514,0.730563,0.731609,
;491:0.732654,0.733697,0.734739,0.735779,0.736817,0.737853,0.738887,0.739920,
;492:0.740951,0.741980,0.743008,0.744034,0.745058,0.746080,0.747101,0.748119,
;493:0.749136,0.750152,0.751165,0.752177,0.753187,0.754195,0.755201,0.756206,
;494:0.757209,0.758210,0.759209,0.760207,0.761202,0.762196,0.763188,0.764179,
;495:0.765167,0.766154,0.767139,0.768122,0.769103,0.770083,0.771061,0.772036,
;496:0.773010,0.773983,0.774953,0.775922,0.776888,0.777853,0.778817,0.779778,
;497:0.780737,0.781695,0.782651,0.783605,0.784557,0.785507,0.786455,0.787402,
;498:0.788346,0.789289,0.790230,0.791169,0.792107,0.793042,0.793975,0.794907,
;499:0.795837,0.796765,0.797691,0.798615,0.799537,0.800458,0.801376,0.802293,
;500:0.803208,0.804120,0.805031,0.805940,0.806848,0.807753,0.808656,0.809558,
;501:0.810457,0.811355,0.812251,0.813144,0.814036,0.814926,0.815814,0.816701,
;502:0.817585,0.818467,0.819348,0.820226,0.821103,0.821977,0.822850,0.823721,
;503:0.824589,0.825456,0.826321,0.827184,0.828045,0.828904,0.829761,0.830616,
;504:0.831470,0.832321,0.833170,0.834018,0.834863,0.835706,0.836548,0.837387,
;505:0.838225,0.839060,0.839894,0.840725,0.841555,0.842383,0.843208,0.844032,
;506:0.844854,0.845673,0.846491,0.847307,0.848120,0.848932,0.849742,0.850549,
;507:0.851355,0.852159,0.852961,0.853760,0.854558,0.855354,0.856147,0.856939,
;508:0.857729,0.858516,0.859302,0.860085,0.860867,0.861646,0.862424,0.863199,
;509:0.863973,0.864744,0.865514,0.866281,0.867046,0.867809,0.868571,0.869330,
;510:0.870087,0.870842,0.871595,0.872346,0.873095,0.873842,0.874587,0.875329,
;511:0.876070,0.876809,0.877545,0.878280,0.879012,0.879743,0.880471,0.881197,
;512:0.881921,0.882643,0.883363,0.884081,0.884797,0.885511,0.886223,0.886932,
;513:0.887640,0.888345,0.889048,0.889750,0.890449,0.891146,0.891841,0.892534,
;514:0.893224,0.893913,0.894599,0.895284,0.895966,0.896646,0.897325,0.898001,
;515:0.898674,0.899346,0.900016,0.900683,0.901349,0.902012,0.902673,0.903332,
;516:0.903989,0.904644,0.905297,0.905947,0.906596,0.907242,0.907886,0.908528,
;517:0.909168,0.909806,0.910441,0.911075,0.911706,0.912335,0.912962,0.913587,
;518:0.914210,0.914830,0.915449,0.916065,0.916679,0.917291,0.917901,0.918508,
;519:0.919114,0.919717,0.920318,0.920917,0.921514,0.922109,0.922701,0.923291,
;520:0.923880,0.924465,0.925049,0.925631,0.926210,0.926787,0.927363,0.927935,
;521:0.928506,0.929075,0.929641,0.930205,0.930767,0.931327,0.931884,0.932440,
;522:0.932993,0.933544,0.934093,0.934639,0.935184,0.935726,0.936266,0.936803,
;523:0.937339,0.937872,0.938404,0.938932,0.939459,0.939984,0.940506,0.941026,
;524:0.941544,0.942060,0.942573,0.943084,0.943593,0.944100,0.944605,0.945107,
;525:0.945607,0.946105,0.946601,0.947094,0.947586,0.948075,0.948561,0.949046,
;526:0.949528,0.950008,0.950486,0.950962,0.951435,0.951906,0.952375,0.952842,
;527:0.953306,0.953768,0.954228,0.954686,0.955141,0.955594,0.956045,0.956494,
;528:0.956940,0.957385,0.957826,0.958266,0.958703,0.959139,0.959572,0.960002,
;529:0.960431,0.960857,0.961280,0.961702,0.962121,0.962538,0.962953,0.963366,
;530:0.963776,0.964184,0.964590,0.964993,0.965394,0.965793,0.966190,0.966584,
;531:0.966976,0.967366,0.967754,0.968139,0.968522,0.968903,0.969281,0.969657,
;532:0.970031,0.970403,0.970772,0.971139,0.971504,0.971866,0.972226,0.972584,
;533:0.972940,0.973293,0.973644,0.973993,0.974339,0.974684,0.975025,0.975365,
;534:0.975702,0.976037,0.976370,0.976700,0.977028,0.977354,0.977677,0.977999,
;535:0.978317,0.978634,0.978948,0.979260,0.979570,0.979877,0.980182,0.980485,
;536:0.980785,0.981083,0.981379,0.981673,0.981964,0.982253,0.982539,0.982824,
;537:0.983105,0.983385,0.983662,0.983937,0.984210,0.984480,0.984749,0.985014,
;538:0.985278,0.985539,0.985798,0.986054,0.986308,0.986560,0.986809,0.987057,
;539:0.987301,0.987544,0.987784,0.988022,0.988258,0.988491,0.988722,0.988950,
;540:0.989177,0.989400,0.989622,0.989841,0.990058,0.990273,0.990485,0.990695,
;541:0.990903,0.991108,0.991311,0.991511,0.991710,0.991906,0.992099,0.992291,
;542:0.992480,0.992666,0.992850,0.993032,0.993212,0.993389,0.993564,0.993737,
;543:0.993907,0.994075,0.994240,0.994404,0.994565,0.994723,0.994879,0.995033,
;544:0.995185,0.995334,0.995481,0.995625,0.995767,0.995907,0.996045,0.996180,
;545:0.996313,0.996443,0.996571,0.996697,0.996820,0.996941,0.997060,0.997176,
;546:0.997290,0.997402,0.997511,0.997618,0.997723,0.997825,0.997925,0.998023,
;547:0.998118,0.998211,0.998302,0.998390,0.998476,0.998559,0.998640,0.998719,
;548:0.998795,0.998870,0.998941,0.999011,0.999078,0.999142,0.999205,0.999265,
;549:0.999322,0.999378,0.999431,0.999481,0.999529,0.999575,0.999619,0.999660,
;550:0.999699,0.999735,0.999769,0.999801,0.999831,0.999858,0.999882,0.999905,
;551:0.999925,0.999942,0.999958,0.999971,0.999981,0.999989,0.999995,0.999999
;552:};
;553:
;554:double sin( double x ) {
;555:	int	index;
;556:	int	quad;
;557:
;558:	index = 1024 * x / (M_PI * 0.5);
;559:	quad = ( index >> 10 ) & 3;
;560:	index &= 1023;
;561:	switch ( quad ) {
;562:	case 0:
;563:		return sintable[index];
;564:	case 1:
;565:		return sintable[1023-index];
;566:	case 2:
;567:		return -sintable[index];
;568:	case 3:
;569:		return -sintable[1023-index];
;570:	}
;571:	return 0;
;572:}
;573:
;574:
;575:double cos( double x ) {
;576:	int	index;
;577:	int	quad;
;578:
;579:	index = 1024 * x / (M_PI * 0.5);
;580:	quad = ( index >> 10 ) & 3;
;581:	index &= 1023;
;582:	switch ( quad ) {
;583:	case 3:
;584:		return sintable[index];
;585:	case 0:
;586:		return sintable[1023-index];
;587:	case 1:
;588:		return -sintable[index];
;589:	case 2:
;590:		return -sintable[1023-index];
;591:	}
;592:	return 0;
;593:}
;594:
;595:
;596:/*
;597:void create_acostable( void ) {
;598:	int i;
;599:	FILE *fp;
;600:	float a;
;601:
;602:	fp = fopen("c:\\acostable.txt", "w");
;603:	fprintf(fp, "float acostable[] = {");
;604:	for (i = 0; i < 1024; i++) {
;605:		if (!(i & 7))
;606:			fprintf(fp, "\n");
;607:		a = acos( (float) -1 + i / 512 );
;608:		fprintf(fp, "%1.8f,", a);
;609:	}
;610:	fprintf(fp, "\n}\n");
;611:	fclose(fp);
;612:}
;613:*/
;614:
;615:float acostable[] = {
;616:3.14159265,3.07908248,3.05317551,3.03328655,3.01651113,3.00172442,2.98834964,2.97604422,
;617:2.96458497,2.95381690,2.94362719,2.93393068,2.92466119,2.91576615,2.90720289,2.89893629,
;618:2.89093699,2.88318015,2.87564455,2.86831188,2.86116621,2.85419358,2.84738169,2.84071962,
;619:2.83419760,2.82780691,2.82153967,2.81538876,2.80934770,2.80341062,2.79757211,2.79182724,
;620:2.78617145,2.78060056,2.77511069,2.76969824,2.76435988,2.75909250,2.75389319,2.74875926,
;621:2.74368816,2.73867752,2.73372510,2.72882880,2.72398665,2.71919677,2.71445741,2.70976688,
;622:2.70512362,2.70052613,2.69597298,2.69146283,2.68699438,2.68256642,2.67817778,2.67382735,
;623:2.66951407,2.66523692,2.66099493,2.65678719,2.65261279,2.64847088,2.64436066,2.64028133,
;624:2.63623214,2.63221238,2.62822133,2.62425835,2.62032277,2.61641398,2.61253138,2.60867440,
;625:2.60484248,2.60103507,2.59725167,2.59349176,2.58975488,2.58604053,2.58234828,2.57867769,
;626:2.57502832,2.57139977,2.56779164,2.56420354,2.56063509,2.55708594,2.55355572,2.55004409,
;627:2.54655073,2.54307530,2.53961750,2.53617701,2.53275354,2.52934680,2.52595650,2.52258238,
;628:2.51922417,2.51588159,2.51255441,2.50924238,2.50594525,2.50266278,2.49939476,2.49614096,
;629:2.49290115,2.48967513,2.48646269,2.48326362,2.48007773,2.47690482,2.47374472,2.47059722,
;630:2.46746215,2.46433933,2.46122860,2.45812977,2.45504269,2.45196720,2.44890314,2.44585034,
;631:2.44280867,2.43977797,2.43675809,2.43374890,2.43075025,2.42776201,2.42478404,2.42181622,
;632:2.41885841,2.41591048,2.41297232,2.41004380,2.40712480,2.40421521,2.40131491,2.39842379,
;633:2.39554173,2.39266863,2.38980439,2.38694889,2.38410204,2.38126374,2.37843388,2.37561237,
;634:2.37279910,2.36999400,2.36719697,2.36440790,2.36162673,2.35885335,2.35608768,2.35332964,
;635:2.35057914,2.34783610,2.34510044,2.34237208,2.33965094,2.33693695,2.33423003,2.33153010,
;636:2.32883709,2.32615093,2.32347155,2.32079888,2.31813284,2.31547337,2.31282041,2.31017388,
;637:2.30753373,2.30489988,2.30227228,2.29965086,2.29703556,2.29442632,2.29182309,2.28922580,
;638:2.28663439,2.28404881,2.28146900,2.27889490,2.27632647,2.27376364,2.27120637,2.26865460,
;639:2.26610827,2.26356735,2.26103177,2.25850149,2.25597646,2.25345663,2.25094195,2.24843238,
;640:2.24592786,2.24342836,2.24093382,2.23844420,2.23595946,2.23347956,2.23100444,2.22853408,
;641:2.22606842,2.22360742,2.22115104,2.21869925,2.21625199,2.21380924,2.21137096,2.20893709,
;642:2.20650761,2.20408248,2.20166166,2.19924511,2.19683280,2.19442469,2.19202074,2.18962092,
;643:2.18722520,2.18483354,2.18244590,2.18006225,2.17768257,2.17530680,2.17293493,2.17056692,
;644:2.16820274,2.16584236,2.16348574,2.16113285,2.15878367,2.15643816,2.15409630,2.15175805,
;645:2.14942338,2.14709226,2.14476468,2.14244059,2.14011997,2.13780279,2.13548903,2.13317865,
;646:2.13087163,2.12856795,2.12626757,2.12397047,2.12167662,2.11938600,2.11709859,2.11481435,
;647:2.11253326,2.11025530,2.10798044,2.10570867,2.10343994,2.10117424,2.09891156,2.09665185,
;648:2.09439510,2.09214129,2.08989040,2.08764239,2.08539725,2.08315496,2.08091550,2.07867884,
;649:2.07644495,2.07421383,2.07198545,2.06975978,2.06753681,2.06531651,2.06309887,2.06088387,
;650:2.05867147,2.05646168,2.05425445,2.05204979,2.04984765,2.04764804,2.04545092,2.04325628,
;651:2.04106409,2.03887435,2.03668703,2.03450211,2.03231957,2.03013941,2.02796159,2.02578610,
;652:2.02361292,2.02144204,2.01927344,2.01710710,2.01494300,2.01278113,2.01062146,2.00846399,
;653:2.00630870,2.00415556,2.00200457,1.99985570,1.99770895,1.99556429,1.99342171,1.99128119,
;654:1.98914271,1.98700627,1.98487185,1.98273942,1.98060898,1.97848051,1.97635399,1.97422942,
;655:1.97210676,1.96998602,1.96786718,1.96575021,1.96363511,1.96152187,1.95941046,1.95730088,
;656:1.95519310,1.95308712,1.95098292,1.94888050,1.94677982,1.94468089,1.94258368,1.94048818,
;657:1.93839439,1.93630228,1.93421185,1.93212308,1.93003595,1.92795046,1.92586659,1.92378433,
;658:1.92170367,1.91962459,1.91754708,1.91547113,1.91339673,1.91132385,1.90925250,1.90718266,
;659:1.90511432,1.90304746,1.90098208,1.89891815,1.89685568,1.89479464,1.89273503,1.89067683,
;660:1.88862003,1.88656463,1.88451060,1.88245794,1.88040664,1.87835668,1.87630806,1.87426076,
;661:1.87221477,1.87017008,1.86812668,1.86608457,1.86404371,1.86200412,1.85996577,1.85792866,
;662:1.85589277,1.85385809,1.85182462,1.84979234,1.84776125,1.84573132,1.84370256,1.84167495,
;663:1.83964848,1.83762314,1.83559892,1.83357582,1.83155381,1.82953289,1.82751305,1.82549429,
;664:1.82347658,1.82145993,1.81944431,1.81742973,1.81541617,1.81340362,1.81139207,1.80938151,
;665:1.80737194,1.80536334,1.80335570,1.80134902,1.79934328,1.79733848,1.79533460,1.79333164,
;666:1.79132959,1.78932843,1.78732817,1.78532878,1.78333027,1.78133261,1.77933581,1.77733985,
;667:1.77534473,1.77335043,1.77135695,1.76936428,1.76737240,1.76538132,1.76339101,1.76140148,
;668:1.75941271,1.75742470,1.75543743,1.75345090,1.75146510,1.74948002,1.74749565,1.74551198,
;669:1.74352900,1.74154672,1.73956511,1.73758417,1.73560389,1.73362426,1.73164527,1.72966692,
;670:1.72768920,1.72571209,1.72373560,1.72175971,1.71978441,1.71780969,1.71583556,1.71386199,
;671:1.71188899,1.70991653,1.70794462,1.70597325,1.70400241,1.70203209,1.70006228,1.69809297,
;672:1.69612416,1.69415584,1.69218799,1.69022062,1.68825372,1.68628727,1.68432127,1.68235571,
;673:1.68039058,1.67842588,1.67646160,1.67449772,1.67253424,1.67057116,1.66860847,1.66664615,
;674:1.66468420,1.66272262,1.66076139,1.65880050,1.65683996,1.65487975,1.65291986,1.65096028,
;675:1.64900102,1.64704205,1.64508338,1.64312500,1.64116689,1.63920905,1.63725148,1.63529416,
;676:1.63333709,1.63138026,1.62942366,1.62746728,1.62551112,1.62355517,1.62159943,1.61964388,
;677:1.61768851,1.61573332,1.61377831,1.61182346,1.60986877,1.60791422,1.60595982,1.60400556,
;678:1.60205142,1.60009739,1.59814349,1.59618968,1.59423597,1.59228235,1.59032882,1.58837536,
;679:1.58642196,1.58446863,1.58251535,1.58056211,1.57860891,1.57665574,1.57470259,1.57274945,
;680:1.57079633,1.56884320,1.56689007,1.56493692,1.56298375,1.56103055,1.55907731,1.55712403,
;681:1.55517069,1.55321730,1.55126383,1.54931030,1.54735668,1.54540297,1.54344917,1.54149526,
;682:1.53954124,1.53758710,1.53563283,1.53367843,1.53172389,1.52976919,1.52781434,1.52585933,
;683:1.52390414,1.52194878,1.51999323,1.51803748,1.51608153,1.51412537,1.51216900,1.51021240,
;684:1.50825556,1.50629849,1.50434117,1.50238360,1.50042576,1.49846765,1.49650927,1.49455060,
;685:1.49259163,1.49063237,1.48867280,1.48671291,1.48475270,1.48279215,1.48083127,1.47887004,
;686:1.47690845,1.47494650,1.47298419,1.47102149,1.46905841,1.46709493,1.46513106,1.46316677,
;687:1.46120207,1.45923694,1.45727138,1.45530538,1.45333893,1.45137203,1.44940466,1.44743682,
;688:1.44546850,1.44349969,1.44153038,1.43956057,1.43759024,1.43561940,1.43364803,1.43167612,
;689:1.42970367,1.42773066,1.42575709,1.42378296,1.42180825,1.41983295,1.41785705,1.41588056,
;690:1.41390346,1.41192573,1.40994738,1.40796840,1.40598877,1.40400849,1.40202755,1.40004594,
;691:1.39806365,1.39608068,1.39409701,1.39211264,1.39012756,1.38814175,1.38615522,1.38416795,
;692:1.38217994,1.38019117,1.37820164,1.37621134,1.37422025,1.37222837,1.37023570,1.36824222,
;693:1.36624792,1.36425280,1.36225684,1.36026004,1.35826239,1.35626387,1.35426449,1.35226422,
;694:1.35026307,1.34826101,1.34625805,1.34425418,1.34224937,1.34024364,1.33823695,1.33622932,
;695:1.33422072,1.33221114,1.33020059,1.32818904,1.32617649,1.32416292,1.32214834,1.32013273,
;696:1.31811607,1.31609837,1.31407960,1.31205976,1.31003885,1.30801684,1.30599373,1.30396951,
;697:1.30194417,1.29991770,1.29789009,1.29586133,1.29383141,1.29180031,1.28976803,1.28773456,
;698:1.28569989,1.28366400,1.28162688,1.27958854,1.27754894,1.27550809,1.27346597,1.27142257,
;699:1.26937788,1.26733189,1.26528459,1.26323597,1.26118602,1.25913471,1.25708205,1.25502803,
;700:1.25297262,1.25091583,1.24885763,1.24679802,1.24473698,1.24267450,1.24061058,1.23854519,
;701:1.23647833,1.23440999,1.23234015,1.23026880,1.22819593,1.22612152,1.22404557,1.22196806,
;702:1.21988898,1.21780832,1.21572606,1.21364219,1.21155670,1.20946958,1.20738080,1.20529037,
;703:1.20319826,1.20110447,1.19900898,1.19691177,1.19481283,1.19271216,1.19060973,1.18850553,
;704:1.18639955,1.18429178,1.18218219,1.18007079,1.17795754,1.17584244,1.17372548,1.17160663,
;705:1.16948589,1.16736324,1.16523866,1.16311215,1.16098368,1.15885323,1.15672081,1.15458638,
;706:1.15244994,1.15031147,1.14817095,1.14602836,1.14388370,1.14173695,1.13958808,1.13743709,
;707:1.13528396,1.13312866,1.13097119,1.12881153,1.12664966,1.12448556,1.12231921,1.12015061,
;708:1.11797973,1.11580656,1.11363107,1.11145325,1.10927308,1.10709055,1.10490563,1.10271831,
;709:1.10052856,1.09833638,1.09614174,1.09394462,1.09174500,1.08954287,1.08733820,1.08513098,
;710:1.08292118,1.08070879,1.07849378,1.07627614,1.07405585,1.07183287,1.06960721,1.06737882,
;711:1.06514770,1.06291382,1.06067715,1.05843769,1.05619540,1.05395026,1.05170226,1.04945136,
;712:1.04719755,1.04494080,1.04268110,1.04041841,1.03815271,1.03588399,1.03361221,1.03133735,
;713:1.02905939,1.02677830,1.02449407,1.02220665,1.01991603,1.01762219,1.01532509,1.01302471,
;714:1.01072102,1.00841400,1.00610363,1.00378986,1.00147268,0.99915206,0.99682798,0.99450039,
;715:0.99216928,0.98983461,0.98749636,0.98515449,0.98280898,0.98045980,0.97810691,0.97575030,
;716:0.97338991,0.97102573,0.96865772,0.96628585,0.96391009,0.96153040,0.95914675,0.95675912,
;717:0.95436745,0.95197173,0.94957191,0.94716796,0.94475985,0.94234754,0.93993099,0.93751017,
;718:0.93508504,0.93265556,0.93022170,0.92778341,0.92534066,0.92289341,0.92044161,0.91798524,
;719:0.91552424,0.91305858,0.91058821,0.90811309,0.90563319,0.90314845,0.90065884,0.89816430,
;720:0.89566479,0.89316028,0.89065070,0.88813602,0.88561619,0.88309116,0.88056088,0.87802531,
;721:0.87548438,0.87293806,0.87038629,0.86782901,0.86526619,0.86269775,0.86012366,0.85754385,
;722:0.85495827,0.85236686,0.84976956,0.84716633,0.84455709,0.84194179,0.83932037,0.83669277,
;723:0.83405893,0.83141877,0.82877225,0.82611928,0.82345981,0.82079378,0.81812110,0.81544172,
;724:0.81275556,0.81006255,0.80736262,0.80465570,0.80194171,0.79922057,0.79649221,0.79375655,
;725:0.79101352,0.78826302,0.78550497,0.78273931,0.77996593,0.77718475,0.77439569,0.77159865,
;726:0.76879355,0.76598029,0.76315878,0.76032891,0.75749061,0.75464376,0.75178826,0.74892402,
;727:0.74605092,0.74316887,0.74027775,0.73737744,0.73446785,0.73154885,0.72862033,0.72568217,
;728:0.72273425,0.71977644,0.71680861,0.71383064,0.71084240,0.70784376,0.70483456,0.70181469,
;729:0.69878398,0.69574231,0.69268952,0.68962545,0.68654996,0.68346288,0.68036406,0.67725332,
;730:0.67413051,0.67099544,0.66784794,0.66468783,0.66151492,0.65832903,0.65512997,0.65191753,
;731:0.64869151,0.64545170,0.64219789,0.63892987,0.63564741,0.63235028,0.62903824,0.62571106,
;732:0.62236849,0.61901027,0.61563615,0.61224585,0.60883911,0.60541564,0.60197515,0.59851735,
;733:0.59504192,0.59154856,0.58803694,0.58450672,0.58095756,0.57738911,0.57380101,0.57019288,
;734:0.56656433,0.56291496,0.55924437,0.55555212,0.55183778,0.54810089,0.54434099,0.54055758,
;735:0.53675018,0.53291825,0.52906127,0.52517867,0.52126988,0.51733431,0.51337132,0.50938028,
;736:0.50536051,0.50131132,0.49723200,0.49312177,0.48897987,0.48480547,0.48059772,0.47635573,
;737:0.47207859,0.46776530,0.46341487,0.45902623,0.45459827,0.45012983,0.44561967,0.44106652,
;738:0.43646903,0.43182577,0.42713525,0.42239588,0.41760600,0.41276385,0.40786755,0.40291513,
;739:0.39790449,0.39283339,0.38769946,0.38250016,0.37723277,0.37189441,0.36648196,0.36099209,
;740:0.35542120,0.34976542,0.34402054,0.33818204,0.33224495,0.32620390,0.32005298,0.31378574,
;741:0.30739505,0.30087304,0.29421096,0.28739907,0.28042645,0.27328078,0.26594810,0.25841250,
;742:0.25065566,0.24265636,0.23438976,0.22582651,0.21693146,0.20766198,0.19796546,0.18777575,
;743:0.17700769,0.16554844,0.15324301,0.13986823,0.12508152,0.10830610,0.08841715,0.06251018,
;744:}
;745:
;746:double acos( double x ) {
;747:	int index;
;748:
;749:	if (x < -1)
;750:		x = -1;
;751:	if (x > 1)
;752:		x = 1;
;753:	index = (float) (1.0 + x) * 511.9;
;754:	return acostable[index];
;755:}
;756:
;757:double atan2( double y, double x ) {
;758:	float	base;
;759:	float	temp;
;760:	float	dir;
;761:	float	test;
;762:	int		i;
;763:
;764:	if ( x < 0 ) {
;765:		if ( y >= 0 ) {
;766:			// quad 1
;767:			base = M_PI / 2;
;768:			temp = x;
;769:			x = y;
;770:			y = -temp;
;771:		} else {
;772:			// quad 2
;773:			base = M_PI;
;774:			x = -x;
;775:			y = -y;
;776:		}
;777:	} else {
;778:		if ( y < 0 ) {
;779:			// quad 3
;780:			base = 3 * M_PI / 2;
;781:			temp = x;
;782:			x = -y;
;783:			y = temp;
;784:		}
;785:	}
;786:
;787:	if ( y > x ) {
;788:		base += M_PI/2;
;789:		temp = x;
;790:		x = y;
;791:		y = temp;
;792:		dir = -1;
;793:	} else {
;794:		dir = 1;
;795:	}
;796:
;797:	// calcualte angle in octant 0
;798:	if ( x == 0 ) {
;799:		return base;
;800:	}
;801:	y /= x;
;802:
;803:	for ( i = 0 ; i < 512 ; i++ ) {
;804:		test = sintable[i] / sintable[1023-i];
;805:		if ( test > y ) {
;806:			break;
;807:		}
;808:	}
;809:
;810:	return base + dir * i * ( M_PI/2048); 
;811:}
;812:
;813:
;814:#endif
;815:
;816:double tan( double x ) {
line 817
;817:	return sin(x) / cos(x);
ADDRFP4 0
INDIRF4
ARGF4
ADDRLP4 0
ADDRGP4 sin
CALLF4
ASGNF4
ADDRFP4 0
INDIRF4
ARGF4
ADDRLP4 4
ADDRGP4 cos
CALLF4
ASGNF4
ADDRLP4 0
INDIRF4
ADDRLP4 4
INDIRF4
DIVF4
RETF4
LABELV $215
endproc tan 8 4
data
align 4
LABELV randSeed
byte 4 0
export srand
code
proc srand 0 0
line 823
;818:}
;819:
;820:
;821:static int randSeed = 0;
;822:
;823:void	srand( unsigned seed ) {
line 824
;824:	randSeed = seed;
ADDRGP4 randSeed
ADDRFP4 0
INDIRU4
CVUI4 4
ASGNI4
line 825
;825:}
LABELV $216
endproc srand 0 0
export rand
proc rand 4 0
line 827
;826:
;827:int		rand( void ) {
line 828
;828:	randSeed = (69069 * randSeed + 1);
ADDRLP4 0
ADDRGP4 randSeed
ASGNP4
ADDRLP4 0
INDIRP4
CNSTI4 69069
ADDRLP4 0
INDIRP4
INDIRI4
MULI4
CNSTI4 1
ADDI4
ASGNI4
line 829
;829:	return randSeed & 0x7fff;
ADDRGP4 randSeed
INDIRI4
CNSTI4 32767
BANDI4
RETI4
LABELV $217
endproc rand 4 0
export atof
proc atof 32 0
line 832
;830:}
;831:
;832:double atof( const char *string ) {
ADDRGP4 $220
JUMPV
LABELV $219
line 839
;833:	float sign;
;834:	float value;
;835:	int		c;
;836:
;837:
;838:	// skip whitespace
;839:	while ( *string <= ' ' ) {
line 840
;840:		if ( !*string ) {
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $222
line 841
;841:			return 0;
CNSTF4 0
RETF4
ADDRGP4 $218
JUMPV
LABELV $222
line 843
;842:		}
;843:		string++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 844
;844:	}
LABELV $220
line 839
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 32
LEI4 $219
line 847
;845:
;846:	// check sign
;847:	switch ( *string ) {
ADDRLP4 12
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 12
INDIRI4
CNSTI4 43
EQI4 $227
ADDRLP4 12
INDIRI4
CNSTI4 45
EQI4 $228
ADDRGP4 $224
JUMPV
LABELV $227
line 849
;848:	case '+':
;849:		string++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 850
;850:		sign = 1;
ADDRLP4 8
CNSTF4 1065353216
ASGNF4
line 851
;851:		break;
ADDRGP4 $225
JUMPV
LABELV $228
line 853
;852:	case '-':
;853:		string++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 854
;854:		sign = -1;
ADDRLP4 8
CNSTF4 3212836864
ASGNF4
line 855
;855:		break;
ADDRGP4 $225
JUMPV
LABELV $224
line 857
;856:	default:
;857:		sign = 1;
ADDRLP4 8
CNSTF4 1065353216
ASGNF4
line 858
;858:		break;
LABELV $225
line 862
;859:	}
;860:
;861:	// read digits
;862:	value = 0;
ADDRLP4 4
CNSTF4 0
ASGNF4
line 863
;863:	c = string[0];
ADDRLP4 0
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
line 864
;864:	if ( c != '.' ) {
ADDRLP4 0
INDIRI4
CNSTI4 46
EQI4 $229
LABELV $231
line 865
;865:		do {
line 866
;866:			c = *string++;
ADDRLP4 20
ADDRFP4 0
INDIRP4
ASGNP4
ADDRFP4 0
ADDRLP4 20
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 0
ADDRLP4 20
INDIRP4
INDIRI1
CVII4 1
ASGNI4
line 867
;867:			if ( c < '0' || c > '9' ) {
ADDRLP4 0
INDIRI4
CNSTI4 48
LTI4 $236
ADDRLP4 0
INDIRI4
CNSTI4 57
LEI4 $234
LABELV $236
line 868
;868:				break;
ADDRGP4 $230
JUMPV
LABELV $234
line 870
;869:			}
;870:			c -= '0';
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 48
SUBI4
ASGNI4
line 871
;871:			value = value * 10 + c;
ADDRLP4 4
CNSTF4 1092616192
ADDRLP4 4
INDIRF4
MULF4
ADDRLP4 0
INDIRI4
CVIF4 4
ADDF4
ASGNF4
line 872
;872:		} while ( 1 );
LABELV $232
ADDRGP4 $231
JUMPV
line 873
;873:	} else {
ADDRGP4 $230
JUMPV
LABELV $229
line 874
;874:		string++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 875
;875:	}
LABELV $230
line 878
;876:
;877:	// check for decimal point
;878:	if ( c == '.' ) {
ADDRLP4 0
INDIRI4
CNSTI4 46
NEI4 $237
line 881
;879:		double fraction;
;880:
;881:		fraction = 0.1;
ADDRLP4 20
CNSTF4 1036831949
ASGNF4
LABELV $239
line 882
;882:		do {
line 883
;883:			c = *string++;
ADDRLP4 24
ADDRFP4 0
INDIRP4
ASGNP4
ADDRFP4 0
ADDRLP4 24
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 0
ADDRLP4 24
INDIRP4
INDIRI1
CVII4 1
ASGNI4
line 884
;884:			if ( c < '0' || c > '9' ) {
ADDRLP4 0
INDIRI4
CNSTI4 48
LTI4 $244
ADDRLP4 0
INDIRI4
CNSTI4 57
LEI4 $242
LABELV $244
line 885
;885:				break;
ADDRGP4 $241
JUMPV
LABELV $242
line 887
;886:			}
;887:			c -= '0';
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 48
SUBI4
ASGNI4
line 888
;888:			value += c * fraction;
ADDRLP4 4
ADDRLP4 4
INDIRF4
ADDRLP4 0
INDIRI4
CVIF4 4
ADDRLP4 20
INDIRF4
MULF4
ADDF4
ASGNF4
line 889
;889:			fraction *= 0.1;
ADDRLP4 20
CNSTF4 1036831949
ADDRLP4 20
INDIRF4
MULF4
ASGNF4
line 890
;890:		} while ( 1 );
LABELV $240
ADDRGP4 $239
JUMPV
LABELV $241
line 892
;891:
;892:	}
LABELV $237
line 896
;893:
;894:	// not handling 10e10 notation...
;895:
;896:	return value * sign;
ADDRLP4 4
INDIRF4
ADDRLP4 8
INDIRF4
MULF4
RETF4
LABELV $218
endproc atof 32 0
export _atof
proc _atof 36 0
line 899
;897:}
;898:
;899:double _atof( const char **stringPtr ) {
line 903
;900:	const char	*string;
;901:	float sign;
;902:	float value;
;903:	int		c = '0';
ADDRLP4 0
CNSTI4 48
ASGNI4
line 905
;904:
;905:	string = *stringPtr;
ADDRLP4 4
ADDRFP4 0
INDIRP4
INDIRP4
ASGNP4
ADDRGP4 $247
JUMPV
LABELV $246
line 908
;906:
;907:	// skip whitespace
;908:	while ( *string <= ' ' ) {
line 909
;909:		if ( !*string ) {
ADDRLP4 4
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $249
line 910
;910:			*stringPtr = string;
ADDRFP4 0
INDIRP4
ADDRLP4 4
INDIRP4
ASGNP4
line 911
;911:			return 0;
CNSTF4 0
RETF4
ADDRGP4 $245
JUMPV
LABELV $249
line 913
;912:		}
;913:		string++;
ADDRLP4 4
ADDRLP4 4
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 914
;914:	}
LABELV $247
line 908
ADDRLP4 4
INDIRP4
INDIRI1
CVII4 1
CNSTI4 32
LEI4 $246
line 917
;915:
;916:	// check sign
;917:	switch ( *string ) {
ADDRLP4 16
ADDRLP4 4
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 16
INDIRI4
CNSTI4 43
EQI4 $254
ADDRLP4 16
INDIRI4
CNSTI4 45
EQI4 $255
ADDRGP4 $251
JUMPV
LABELV $254
line 919
;918:	case '+':
;919:		string++;
ADDRLP4 4
ADDRLP4 4
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 920
;920:		sign = 1;
ADDRLP4 12
CNSTF4 1065353216
ASGNF4
line 921
;921:		break;
ADDRGP4 $252
JUMPV
LABELV $255
line 923
;922:	case '-':
;923:		string++;
ADDRLP4 4
ADDRLP4 4
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 924
;924:		sign = -1;
ADDRLP4 12
CNSTF4 3212836864
ASGNF4
line 925
;925:		break;
ADDRGP4 $252
JUMPV
LABELV $251
line 927
;926:	default:
;927:		sign = 1;
ADDRLP4 12
CNSTF4 1065353216
ASGNF4
line 928
;928:		break;
LABELV $252
line 932
;929:	}
;930:
;931:	// read digits
;932:	value = 0;
ADDRLP4 8
CNSTF4 0
ASGNF4
line 933
;933:	if ( string[0] != '.' ) {
ADDRLP4 4
INDIRP4
INDIRI1
CVII4 1
CNSTI4 46
EQI4 $256
LABELV $258
line 934
;934:		do {
line 935
;935:			c = *string++;
ADDRLP4 24
ADDRLP4 4
INDIRP4
ASGNP4
ADDRLP4 4
ADDRLP4 24
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 0
ADDRLP4 24
INDIRP4
INDIRI1
CVII4 1
ASGNI4
line 936
;936:			if ( c < '0' || c > '9' ) {
ADDRLP4 0
INDIRI4
CNSTI4 48
LTI4 $263
ADDRLP4 0
INDIRI4
CNSTI4 57
LEI4 $261
LABELV $263
line 937
;937:				break;
ADDRGP4 $260
JUMPV
LABELV $261
line 939
;938:			}
;939:			c -= '0';
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 48
SUBI4
ASGNI4
line 940
;940:			value = value * 10 + c;
ADDRLP4 8
CNSTF4 1092616192
ADDRLP4 8
INDIRF4
MULF4
ADDRLP4 0
INDIRI4
CVIF4 4
ADDF4
ASGNF4
line 941
;941:		} while ( 1 );
LABELV $259
ADDRGP4 $258
JUMPV
LABELV $260
line 942
;942:	}
LABELV $256
line 945
;943:
;944:	// check for decimal point
;945:	if ( c == '.' ) {
ADDRLP4 0
INDIRI4
CNSTI4 46
NEI4 $264
line 948
;946:		double fraction;
;947:
;948:		fraction = 0.1;
ADDRLP4 24
CNSTF4 1036831949
ASGNF4
LABELV $266
line 949
;949:		do {
line 950
;950:			c = *string++;
ADDRLP4 28
ADDRLP4 4
INDIRP4
ASGNP4
ADDRLP4 4
ADDRLP4 28
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 0
ADDRLP4 28
INDIRP4
INDIRI1
CVII4 1
ASGNI4
line 951
;951:			if ( c < '0' || c > '9' ) {
ADDRLP4 0
INDIRI4
CNSTI4 48
LTI4 $271
ADDRLP4 0
INDIRI4
CNSTI4 57
LEI4 $269
LABELV $271
line 952
;952:				break;
ADDRGP4 $268
JUMPV
LABELV $269
line 954
;953:			}
;954:			c -= '0';
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 48
SUBI4
ASGNI4
line 955
;955:			value += c * fraction;
ADDRLP4 8
ADDRLP4 8
INDIRF4
ADDRLP4 0
INDIRI4
CVIF4 4
ADDRLP4 24
INDIRF4
MULF4
ADDF4
ASGNF4
line 956
;956:			fraction *= 0.1;
ADDRLP4 24
CNSTF4 1036831949
ADDRLP4 24
INDIRF4
MULF4
ASGNF4
line 957
;957:		} while ( 1 );
LABELV $267
ADDRGP4 $266
JUMPV
LABELV $268
line 959
;958:
;959:	}
LABELV $264
line 962
;960:
;961:	// not handling 10e10 notation...
;962:	*stringPtr = string;
ADDRFP4 0
INDIRP4
ADDRLP4 4
INDIRP4
ASGNP4
line 964
;963:
;964:	return value * sign;
ADDRLP4 8
INDIRF4
ADDRLP4 12
INDIRF4
MULF4
RETF4
LABELV $245
endproc _atof 36 0
export strtod
proc strtod 60 12
line 982
;965:}
;966:
;967:/*
;968:==============
;969:strtod
;970:
;971:Without an errno variable, this is a fair bit less useful than it is in libc
;972:but it's still a fair bit more capable than atof or _atof
;973:Handles inf[inity], nan (ignoring case), hexadecimals, and decimals
;974:Handles decimal exponents like 10e10 and hex exponents like 0x7f8p20
;975:10e10 == 10000000000 (power of ten)
;976:0x7f8p20 == 0x7f800000 (decimal power of two)
;977:The variable pointed to by endptr will hold the location of the first character
;978:in the nptr string that was not used in the conversion
;979:==============
;980:*/
;981:double strtod( const char *nptr, const char **endptr )
;982:{
line 984
;983:	double res;
;984:	qboolean neg = qfalse;
ADDRLP4 4
CNSTI4 0
ASGNI4
ADDRGP4 $274
JUMPV
LABELV $273
line 988
;985:
;986:	// skip whitespace
;987:	while( isspace( *nptr ) )
;988:		nptr++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
LABELV $274
line 987
ADDRLP4 8
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 8
INDIRI4
CNSTI4 32
EQI4 $273
ADDRLP4 8
INDIRI4
CNSTI4 12
EQI4 $273
ADDRLP4 8
INDIRI4
CNSTI4 10
EQI4 $273
ADDRLP4 8
INDIRI4
CNSTI4 13
EQI4 $273
ADDRLP4 8
INDIRI4
CNSTI4 9
EQI4 $273
ADDRLP4 8
INDIRI4
CNSTI4 11
EQI4 $273
line 991
;989:
;990:	// special string parsing
;991:	if( Q_stricmpn( nptr, "nan", 3 ) == 0 )
ADDRFP4 0
INDIRP4
ARGP4
ADDRGP4 $278
ARGP4
CNSTI4 3
ARGI4
ADDRLP4 12
ADDRGP4 Q_stricmpn
CALLI4
ASGNI4
ADDRLP4 12
INDIRI4
CNSTI4 0
NEI4 $276
line 992
;992:	{
line 994
;993:		floatint_t nan;
;994:		if( endptr == NULL )
ADDRFP4 4
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $279
line 995
;995:		{
line 996
;996:			nan.ui = 0x7fffffff;
ADDRLP4 16
CNSTU4 2147483647
ASGNU4
line 997
;997:			return nan.f;
ADDRLP4 16
INDIRF4
RETF4
ADDRGP4 $272
JUMPV
LABELV $279
line 999
;998:		}
;999:		*endptr = &nptr[3];
ADDRFP4 4
INDIRP4
ADDRFP4 0
INDIRP4
CNSTI4 3
ADDP4
ASGNP4
line 1005
;1000:		// nan can be followed by a bracketed number (in hex, octal,
;1001:		// or decimal) which is then put in the mantissa
;1002:		// this can be used to generate signalling or quiet NaNs, for
;1003:		// example (though I doubt it'll ever be used)
;1004:		// note that nan(0) is infinity!
;1005:		if( nptr[3] == '(' )
ADDRFP4 0
INDIRP4
CNSTI4 3
ADDP4
INDIRI1
CVII4 1
CNSTI4 40
NEI4 $281
line 1006
;1006:		{
line 1008
;1007:			const char *end;
;1008:			int mantissa = strtol( &nptr[4], &end, 0 );
ADDRFP4 0
INDIRP4
CNSTI4 4
ADDP4
ARGP4
ADDRLP4 24
ARGP4
CNSTI4 0
ARGI4
ADDRLP4 28
ADDRGP4 strtol
CALLI4
ASGNI4
ADDRLP4 20
ADDRLP4 28
INDIRI4
ASGNI4
line 1009
;1009:			if( *end == ')' )
ADDRLP4 24
INDIRP4
INDIRI1
CVII4 1
CNSTI4 41
NEI4 $283
line 1010
;1010:			{
line 1011
;1011:				nan.ui = 0x7f800000 | ( mantissa & 0x7fffff );
ADDRLP4 16
ADDRLP4 20
INDIRI4
CNSTI4 8388607
BANDI4
CNSTI4 2139095040
BORI4
CVIU4 4
ASGNU4
line 1012
;1012:				if( endptr )
ADDRFP4 4
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $285
line 1013
;1013:					*endptr = &end[1];
ADDRFP4 4
INDIRP4
ADDRLP4 24
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
LABELV $285
line 1014
;1014:				return nan.f;
ADDRLP4 16
INDIRF4
RETF4
ADDRGP4 $272
JUMPV
LABELV $283
line 1016
;1015:			}
;1016:		}
LABELV $281
line 1017
;1017:		nan.ui = 0x7fffffff;
ADDRLP4 16
CNSTU4 2147483647
ASGNU4
line 1018
;1018:		return nan.f;
ADDRLP4 16
INDIRF4
RETF4
ADDRGP4 $272
JUMPV
LABELV $276
line 1020
;1019:	}
;1020:	if( Q_stricmpn( nptr, "inf", 3 ) == 0 )
ADDRFP4 0
INDIRP4
ARGP4
ADDRGP4 $289
ARGP4
CNSTI4 3
ARGI4
ADDRLP4 16
ADDRGP4 Q_stricmpn
CALLI4
ASGNI4
ADDRLP4 16
INDIRI4
CNSTI4 0
NEI4 $287
line 1021
;1021:	{
line 1023
;1022:		floatint_t inf;
;1023:		inf.ui = 0x7f800000;
ADDRLP4 20
CNSTU4 2139095040
ASGNU4
line 1024
;1024:		if( endptr == NULL )
ADDRFP4 4
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $290
line 1025
;1025:			return inf.f;
ADDRLP4 20
INDIRF4
RETF4
ADDRGP4 $272
JUMPV
LABELV $290
line 1026
;1026:		if( Q_stricmpn( &nptr[3], "inity", 5 ) == 0 )
ADDRFP4 0
INDIRP4
CNSTI4 3
ADDP4
ARGP4
ADDRGP4 $294
ARGP4
CNSTI4 5
ARGI4
ADDRLP4 24
ADDRGP4 Q_stricmpn
CALLI4
ASGNI4
ADDRLP4 24
INDIRI4
CNSTI4 0
NEI4 $292
line 1027
;1027:			*endptr = &nptr[8];
ADDRFP4 4
INDIRP4
ADDRFP4 0
INDIRP4
CNSTI4 8
ADDP4
ASGNP4
ADDRGP4 $293
JUMPV
LABELV $292
line 1029
;1028:		else
;1029:			*endptr = &nptr[3];
ADDRFP4 4
INDIRP4
ADDRFP4 0
INDIRP4
CNSTI4 3
ADDP4
ASGNP4
LABELV $293
line 1030
;1030:		return inf.f;
ADDRLP4 20
INDIRF4
RETF4
ADDRGP4 $272
JUMPV
LABELV $287
line 1035
;1031:	}
;1032:
;1033:	// normal numeric parsing
;1034:	// sign
;1035:	if( *nptr == '-' )
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 45
NEI4 $295
line 1036
;1036:	{
line 1037
;1037:		nptr++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 1038
;1038:		neg = qtrue;
ADDRLP4 4
CNSTI4 1
ASGNI4
line 1039
;1039:	}
ADDRGP4 $296
JUMPV
LABELV $295
line 1040
;1040:	else if( *nptr == '+' )
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 43
NEI4 $297
line 1041
;1041:		nptr++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
LABELV $297
LABELV $296
line 1043
;1042:	// hex
;1043:	if( Q_stricmpn( nptr, "0x", 2 ) == 0 )
ADDRFP4 0
INDIRP4
ARGP4
ADDRGP4 $301
ARGP4
CNSTI4 2
ARGI4
ADDRLP4 20
ADDRGP4 Q_stricmpn
CALLI4
ASGNI4
ADDRLP4 20
INDIRI4
CNSTI4 0
NEI4 $299
line 1044
;1044:	{
line 1046
;1045:		// track if we use any digits
;1046:		const char *s = &nptr[1], *end = s;
ADDRLP4 28
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 24
ADDRLP4 28
INDIRP4
ASGNP4
line 1047
;1047:		nptr += 2;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 2
ADDP4
ASGNP4
line 1048
;1048:		res = 0;
ADDRLP4 0
CNSTF4 0
ASGNF4
ADDRGP4 $303
JUMPV
LABELV $302
line 1050
;1049:		while( qtrue )
;1050:		{
line 1051
;1051:			if( isdigit( *nptr ) )
ADDRLP4 32
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 32
INDIRI4
CNSTI4 48
LTI4 $305
ADDRLP4 32
INDIRI4
CNSTI4 57
GTI4 $305
line 1052
;1052:				res = 16 * res + ( *nptr++ - '0' );
ADDRLP4 36
ADDRFP4 0
INDIRP4
ASGNP4
ADDRFP4 0
ADDRLP4 36
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 0
CNSTF4 1098907648
ADDRLP4 0
INDIRF4
MULF4
ADDRLP4 36
INDIRP4
INDIRI1
CVII4 1
CNSTI4 48
SUBI4
CVIF4 4
ADDF4
ASGNF4
ADDRGP4 $306
JUMPV
LABELV $305
line 1053
;1053:			else if( *nptr >= 'A' && *nptr <= 'F' )
ADDRLP4 40
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 40
INDIRI4
CNSTI4 65
LTI4 $307
ADDRLP4 40
INDIRI4
CNSTI4 70
GTI4 $307
line 1054
;1054:				res = 16 * res + 10 + *nptr++ - 'A';
ADDRLP4 44
ADDRFP4 0
INDIRP4
ASGNP4
ADDRFP4 0
ADDRLP4 44
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 0
CNSTF4 1098907648
ADDRLP4 0
INDIRF4
MULF4
CNSTF4 1092616192
ADDF4
ADDRLP4 44
INDIRP4
INDIRI1
CVII4 1
CVIF4 4
ADDF4
CNSTF4 1115815936
SUBF4
ASGNF4
ADDRGP4 $308
JUMPV
LABELV $307
line 1055
;1055:			else if( *nptr >= 'a' && *nptr <= 'f' )
ADDRLP4 48
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 48
INDIRI4
CNSTI4 97
LTI4 $304
ADDRLP4 48
INDIRI4
CNSTI4 102
GTI4 $304
line 1056
;1056:				res = 16 * res + 10 + *nptr++ - 'a';
ADDRLP4 52
ADDRFP4 0
INDIRP4
ASGNP4
ADDRFP4 0
ADDRLP4 52
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 0
CNSTF4 1098907648
ADDRLP4 0
INDIRF4
MULF4
CNSTF4 1092616192
ADDF4
ADDRLP4 52
INDIRP4
INDIRI1
CVII4 1
CVIF4 4
ADDF4
CNSTF4 1120010240
SUBF4
ASGNF4
line 1058
;1057:			else
;1058:				break;
LABELV $310
LABELV $308
LABELV $306
line 1059
;1059:		}
LABELV $303
line 1049
ADDRGP4 $302
JUMPV
LABELV $304
line 1061
;1060:		// if nptr moved, save it
;1061:		if( end + 1 < nptr )
ADDRLP4 24
INDIRP4
CNSTI4 1
ADDP4
CVPU4 4
ADDRFP4 0
INDIRP4
CVPU4 4
GEU4 $311
line 1062
;1062:			end = nptr;
ADDRLP4 24
ADDRFP4 0
INDIRP4
ASGNP4
LABELV $311
line 1063
;1063:		if( *nptr == '.' )
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 46
NEI4 $313
line 1064
;1064:		{
line 1066
;1065:			float place;
;1066:			nptr++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 1071
;1067:			// 1.0 / 16.0 == 0.0625
;1068:			// I don't expect the float accuracy to hold out for
;1069:			// very long but since we need to know the length of
;1070:			// the string anyway we keep on going regardless
;1071:			for( place = 0.0625;; place /= 16.0 )
ADDRLP4 32
CNSTF4 1031798784
ASGNF4
LABELV $315
line 1072
;1072:			{
line 1073
;1073:				if( isdigit( *nptr ) )
ADDRLP4 36
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 36
INDIRI4
CNSTI4 48
LTI4 $319
ADDRLP4 36
INDIRI4
CNSTI4 57
GTI4 $319
line 1074
;1074:					res += place * ( *nptr++ - '0' );
ADDRLP4 40
ADDRFP4 0
INDIRP4
ASGNP4
ADDRFP4 0
ADDRLP4 40
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 0
ADDRLP4 0
INDIRF4
ADDRLP4 32
INDIRF4
ADDRLP4 40
INDIRP4
INDIRI1
CVII4 1
CNSTI4 48
SUBI4
CVIF4 4
MULF4
ADDF4
ASGNF4
ADDRGP4 $320
JUMPV
LABELV $319
line 1075
;1075:				else if( *nptr >= 'A' && *nptr <= 'F' )
ADDRLP4 44
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 44
INDIRI4
CNSTI4 65
LTI4 $321
ADDRLP4 44
INDIRI4
CNSTI4 70
GTI4 $321
line 1076
;1076:					res += place * ( 10 + *nptr++ - 'A' );
ADDRLP4 48
ADDRFP4 0
INDIRP4
ASGNP4
ADDRFP4 0
ADDRLP4 48
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 0
ADDRLP4 0
INDIRF4
ADDRLP4 32
INDIRF4
ADDRLP4 48
INDIRP4
INDIRI1
CVII4 1
CNSTI4 10
ADDI4
CNSTI4 65
SUBI4
CVIF4 4
MULF4
ADDF4
ASGNF4
ADDRGP4 $322
JUMPV
LABELV $321
line 1077
;1077:				else if( *nptr >= 'a' && *nptr <= 'f' )
ADDRLP4 52
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 52
INDIRI4
CNSTI4 97
LTI4 $317
ADDRLP4 52
INDIRI4
CNSTI4 102
GTI4 $317
line 1078
;1078:					res += place * ( 10 + *nptr++ - 'a' );
ADDRLP4 56
ADDRFP4 0
INDIRP4
ASGNP4
ADDRFP4 0
ADDRLP4 56
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 0
ADDRLP4 0
INDIRF4
ADDRLP4 32
INDIRF4
ADDRLP4 56
INDIRP4
INDIRI1
CVII4 1
CNSTI4 10
ADDI4
CNSTI4 97
SUBI4
CVIF4 4
MULF4
ADDF4
ASGNF4
line 1080
;1079:				else
;1080:					break;
LABELV $324
LABELV $322
LABELV $320
line 1081
;1081:			}
LABELV $316
line 1071
ADDRLP4 32
ADDRLP4 32
INDIRF4
CNSTF4 1098907648
DIVF4
ASGNF4
ADDRGP4 $315
JUMPV
LABELV $317
line 1082
;1082:			if( end < nptr )
ADDRLP4 24
INDIRP4
CVPU4 4
ADDRFP4 0
INDIRP4
CVPU4 4
GEU4 $325
line 1083
;1083:				end = nptr;
ADDRLP4 24
ADDRFP4 0
INDIRP4
ASGNP4
LABELV $325
line 1084
;1084:		}
LABELV $313
line 1089
;1085:		// parse an optional exponent, representing multiplication
;1086:		// by a power of two
;1087:		// exponents are only valid if we encountered at least one
;1088:		// digit already (and have therefore set end to something)
;1089:		if( end != s && tolower( *nptr ) == 'p' )
ADDRLP4 24
INDIRP4
CVPU4 4
ADDRLP4 28
INDIRP4
CVPU4 4
EQU4 $327
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ARGI4
ADDRLP4 32
ADDRGP4 tolower
CALLI4
ASGNI4
ADDRLP4 32
INDIRI4
CNSTI4 112
NEI4 $327
line 1090
;1090:		{
line 1095
;1091:			int exp;
;1092:			float res2;
;1093:			// apparently (confusingly) the exponent should be
;1094:			// decimal
;1095:			exp = strtol( &nptr[1], &end, 10 );
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ARGP4
ADDRLP4 24
ARGP4
CNSTI4 10
ARGI4
ADDRLP4 44
ADDRGP4 strtol
CALLI4
ASGNI4
ADDRLP4 40
ADDRLP4 44
INDIRI4
ASGNI4
line 1096
;1096:			if( &nptr[1] == end )
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
CVPU4 4
ADDRLP4 24
INDIRP4
CVPU4 4
NEU4 $329
line 1097
;1097:			{
line 1099
;1098:				// no exponent
;1099:				if( endptr )
ADDRFP4 4
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $331
line 1100
;1100:					*endptr = nptr;
ADDRFP4 4
INDIRP4
ADDRFP4 0
INDIRP4
ASGNP4
LABELV $331
line 1101
;1101:				return res;
ADDRLP4 0
INDIRF4
RETF4
ADDRGP4 $272
JUMPV
LABELV $329
line 1103
;1102:			}
;1103:			if( exp > 0 )
ADDRLP4 40
INDIRI4
CNSTI4 0
LEI4 $341
line 1104
;1104:			{
ADDRGP4 $336
JUMPV
LABELV $335
line 1106
;1105:				while( exp-- > 0 )
;1106:				{
line 1107
;1107:					res2 = res * 2;
ADDRLP4 36
CNSTF4 1073741824
ADDRLP4 0
INDIRF4
MULF4
ASGNF4
line 1109
;1108:					// check for infinity
;1109:					if( res2 <= res )
ADDRLP4 36
INDIRF4
ADDRLP4 0
INDIRF4
GTF4 $338
line 1110
;1110:						break;
ADDRGP4 $334
JUMPV
LABELV $338
line 1111
;1111:					res = res2;
ADDRLP4 0
ADDRLP4 36
INDIRF4
ASGNF4
line 1112
;1112:				}
LABELV $336
line 1105
ADDRLP4 48
ADDRLP4 40
INDIRI4
ASGNI4
ADDRLP4 40
ADDRLP4 48
INDIRI4
CNSTI4 1
SUBI4
ASGNI4
ADDRLP4 48
INDIRI4
CNSTI4 0
GTI4 $335
line 1113
;1113:			}
ADDRGP4 $334
JUMPV
line 1115
;1114:			else
;1115:			{
LABELV $340
line 1117
;1116:				while( exp++ < 0 )
;1117:				{
line 1118
;1118:					res2 = res / 2;
ADDRLP4 36
ADDRLP4 0
INDIRF4
CNSTF4 1073741824
DIVF4
ASGNF4
line 1120
;1119:					// check for underflow
;1120:					if( res2 >= res )
ADDRLP4 36
INDIRF4
ADDRLP4 0
INDIRF4
LTF4 $343
line 1121
;1121:						break;
ADDRGP4 $342
JUMPV
LABELV $343
line 1122
;1122:					res = res2;
ADDRLP4 0
ADDRLP4 36
INDIRF4
ASGNF4
line 1123
;1123:				}
LABELV $341
line 1116
ADDRLP4 48
ADDRLP4 40
INDIRI4
ASGNI4
ADDRLP4 40
ADDRLP4 48
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
ADDRLP4 48
INDIRI4
CNSTI4 0
LTI4 $340
LABELV $342
line 1124
;1124:			}
LABELV $334
line 1125
;1125:		}
LABELV $327
line 1126
;1126:		if( endptr )
ADDRFP4 4
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $345
line 1127
;1127:			*endptr = end;
ADDRFP4 4
INDIRP4
ADDRLP4 24
INDIRP4
ASGNP4
LABELV $345
line 1128
;1128:		return res;
ADDRLP4 0
INDIRF4
RETF4
ADDRGP4 $272
JUMPV
LABELV $299
line 1132
;1129:	}
;1130:	// decimal
;1131:	else
;1132:	{
line 1134
;1133:		// track if we find any digits
;1134:		const char *end = nptr, *p = nptr;
ADDRLP4 24
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 28
ADDRFP4 0
INDIRP4
ASGNP4
line 1136
;1135:		// this is most of the work
;1136:		for( res = 0; isdigit( *nptr );
ADDRLP4 0
CNSTF4 0
ASGNF4
ADDRGP4 $350
JUMPV
LABELV $347
line 1137
;1137:			res = 10 * res + *nptr++ - '0' );
LABELV $348
ADDRLP4 32
ADDRFP4 0
INDIRP4
ASGNP4
ADDRFP4 0
ADDRLP4 32
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 0
CNSTF4 1092616192
ADDRLP4 0
INDIRF4
MULF4
ADDRLP4 32
INDIRP4
INDIRI1
CVII4 1
CVIF4 4
ADDF4
CNSTF4 1111490560
SUBF4
ASGNF4
LABELV $350
line 1136
ADDRLP4 36
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 36
INDIRI4
CNSTI4 48
LTI4 $351
ADDRLP4 36
INDIRI4
CNSTI4 57
LEI4 $347
LABELV $351
line 1139
;1138:		// if nptr moved, we read something
;1139:		if( end < nptr )
ADDRLP4 24
INDIRP4
CVPU4 4
ADDRFP4 0
INDIRP4
CVPU4 4
GEU4 $352
line 1140
;1140:			end = nptr;
ADDRLP4 24
ADDRFP4 0
INDIRP4
ASGNP4
LABELV $352
line 1141
;1141:		if( *nptr == '.' )
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 46
NEI4 $354
line 1142
;1142:		{
line 1145
;1143:			// fractional part
;1144:			float place;
;1145:			nptr++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 1146
;1146:			for( place = 0.1; isdigit( *nptr ); place /= 10.0 )
ADDRLP4 40
CNSTF4 1036831949
ASGNF4
ADDRGP4 $359
JUMPV
LABELV $356
line 1147
;1147:				res += ( *nptr++ - '0' ) * place;
ADDRLP4 44
ADDRFP4 0
INDIRP4
ASGNP4
ADDRFP4 0
ADDRLP4 44
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 0
ADDRLP4 0
INDIRF4
ADDRLP4 44
INDIRP4
INDIRI1
CVII4 1
CNSTI4 48
SUBI4
CVIF4 4
ADDRLP4 40
INDIRF4
MULF4
ADDF4
ASGNF4
LABELV $357
line 1146
ADDRLP4 40
ADDRLP4 40
INDIRF4
CNSTF4 1092616192
DIVF4
ASGNF4
LABELV $359
ADDRLP4 48
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 48
INDIRI4
CNSTI4 48
LTI4 $360
ADDRLP4 48
INDIRI4
CNSTI4 57
LEI4 $356
LABELV $360
line 1149
;1148:			// if nptr moved, we read something
;1149:			if( end + 1 < nptr )
ADDRLP4 24
INDIRP4
CNSTI4 1
ADDP4
CVPU4 4
ADDRFP4 0
INDIRP4
CVPU4 4
GEU4 $361
line 1150
;1150:				end = nptr;
ADDRLP4 24
ADDRFP4 0
INDIRP4
ASGNP4
LABELV $361
line 1151
;1151:		}
LABELV $354
line 1155
;1152:		// exponent
;1153:		// meaningless without having already read digits, so check
;1154:		// we've set end to something
;1155:		if( p != end && tolower( *nptr ) == 'e' )
ADDRLP4 28
INDIRP4
CVPU4 4
ADDRLP4 24
INDIRP4
CVPU4 4
EQU4 $363
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ARGI4
ADDRLP4 40
ADDRGP4 tolower
CALLI4
ASGNI4
ADDRLP4 40
INDIRI4
CNSTI4 101
NEI4 $363
line 1156
;1156:		{
line 1159
;1157:			int exp;
;1158:			float res10;
;1159:			exp = strtol( &nptr[1], &end, 10 );
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ARGP4
ADDRLP4 24
ARGP4
CNSTI4 10
ARGI4
ADDRLP4 52
ADDRGP4 strtol
CALLI4
ASGNI4
ADDRLP4 48
ADDRLP4 52
INDIRI4
ASGNI4
line 1160
;1160:			if( &nptr[1] == end )
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
CVPU4 4
ADDRLP4 24
INDIRP4
CVPU4 4
NEU4 $365
line 1161
;1161:			{
line 1163
;1162:				// no exponent
;1163:				if( endptr )
ADDRFP4 4
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $367
line 1164
;1164:					*endptr = nptr;
ADDRFP4 4
INDIRP4
ADDRFP4 0
INDIRP4
ASGNP4
LABELV $367
line 1165
;1165:				return res;
ADDRLP4 0
INDIRF4
RETF4
ADDRGP4 $272
JUMPV
LABELV $365
line 1167
;1166:			}
;1167:			if( exp > 0 )
ADDRLP4 48
INDIRI4
CNSTI4 0
LEI4 $369
line 1168
;1168:			{
ADDRGP4 $372
JUMPV
LABELV $371
line 1170
;1169:				while( exp-- > 0 )
;1170:				{
line 1171
;1171:					res10 = res * 10;
ADDRLP4 44
CNSTF4 1092616192
ADDRLP4 0
INDIRF4
MULF4
ASGNF4
line 1173
;1172:					// check for infinity to save us time
;1173:					if( res10 <= res )
ADDRLP4 44
INDIRF4
ADDRLP4 0
INDIRF4
GTF4 $374
line 1174
;1174:						break;
ADDRGP4 $370
JUMPV
LABELV $374
line 1175
;1175:					res = res10;
ADDRLP4 0
ADDRLP4 44
INDIRF4
ASGNF4
line 1176
;1176:				}
LABELV $372
line 1169
ADDRLP4 56
ADDRLP4 48
INDIRI4
ASGNI4
ADDRLP4 48
ADDRLP4 56
INDIRI4
CNSTI4 1
SUBI4
ASGNI4
ADDRLP4 56
INDIRI4
CNSTI4 0
GTI4 $371
line 1177
;1177:			}
ADDRGP4 $370
JUMPV
LABELV $369
line 1178
;1178:			else if( exp < 0 )
ADDRLP4 48
INDIRI4
CNSTI4 0
GEI4 $376
line 1179
;1179:			{
ADDRGP4 $379
JUMPV
LABELV $378
line 1181
;1180:				while( exp++ < 0 )
;1181:				{
line 1182
;1182:					res10 = res / 10;
ADDRLP4 44
ADDRLP4 0
INDIRF4
CNSTF4 1092616192
DIVF4
ASGNF4
line 1186
;1183:					// check for underflow
;1184:					// (test for 0 would probably be just
;1185:					// as good)
;1186:					if( res10 >= res )
ADDRLP4 44
INDIRF4
ADDRLP4 0
INDIRF4
LTF4 $381
line 1187
;1187:						break;
ADDRGP4 $380
JUMPV
LABELV $381
line 1188
;1188:					res = res10;
ADDRLP4 0
ADDRLP4 44
INDIRF4
ASGNF4
line 1189
;1189:				}
LABELV $379
line 1180
ADDRLP4 56
ADDRLP4 48
INDIRI4
ASGNI4
ADDRLP4 48
ADDRLP4 56
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
ADDRLP4 56
INDIRI4
CNSTI4 0
LTI4 $378
LABELV $380
line 1190
;1190:			}
LABELV $376
LABELV $370
line 1191
;1191:		}
LABELV $363
line 1192
;1192:		if( endptr )
ADDRFP4 4
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $383
line 1193
;1193:			*endptr = end;
ADDRFP4 4
INDIRP4
ADDRLP4 24
INDIRP4
ASGNP4
LABELV $383
line 1194
;1194:		return res;
ADDRLP4 0
INDIRF4
RETF4
LABELV $272
endproc strtod 60 12
export atoi
proc atoi 28 0
line 1198
;1195:	}
;1196:}
;1197:
;1198:int atoi( const char *string ) {
ADDRGP4 $387
JUMPV
LABELV $386
line 1205
;1199:	int		sign;
;1200:	int		value;
;1201:	int		c;
;1202:
;1203:
;1204:	// skip whitespace
;1205:	while ( *string <= ' ' ) {
line 1206
;1206:		if ( !*string ) {
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $389
line 1207
;1207:			return 0;
CNSTI4 0
RETI4
ADDRGP4 $385
JUMPV
LABELV $389
line 1209
;1208:		}
;1209:		string++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 1210
;1210:	}
LABELV $387
line 1205
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 32
LEI4 $386
line 1213
;1211:
;1212:	// check sign
;1213:	switch ( *string ) {
ADDRLP4 12
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 12
INDIRI4
CNSTI4 43
EQI4 $394
ADDRLP4 12
INDIRI4
CNSTI4 45
EQI4 $395
ADDRGP4 $391
JUMPV
LABELV $394
line 1215
;1214:	case '+':
;1215:		string++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 1216
;1216:		sign = 1;
ADDRLP4 8
CNSTI4 1
ASGNI4
line 1217
;1217:		break;
ADDRGP4 $392
JUMPV
LABELV $395
line 1219
;1218:	case '-':
;1219:		string++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 1220
;1220:		sign = -1;
ADDRLP4 8
CNSTI4 -1
ASGNI4
line 1221
;1221:		break;
ADDRGP4 $392
JUMPV
LABELV $391
line 1223
;1222:	default:
;1223:		sign = 1;
ADDRLP4 8
CNSTI4 1
ASGNI4
line 1224
;1224:		break;
LABELV $392
line 1228
;1225:	}
;1226:
;1227:	// read digits
;1228:	value = 0;
ADDRLP4 4
CNSTI4 0
ASGNI4
LABELV $396
line 1229
;1229:	do {
line 1230
;1230:		c = *string++;
ADDRLP4 20
ADDRFP4 0
INDIRP4
ASGNP4
ADDRFP4 0
ADDRLP4 20
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 0
ADDRLP4 20
INDIRP4
INDIRI1
CVII4 1
ASGNI4
line 1231
;1231:		if ( c < '0' || c > '9' ) {
ADDRLP4 0
INDIRI4
CNSTI4 48
LTI4 $401
ADDRLP4 0
INDIRI4
CNSTI4 57
LEI4 $399
LABELV $401
line 1232
;1232:			break;
ADDRGP4 $398
JUMPV
LABELV $399
line 1234
;1233:		}
;1234:		c -= '0';
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 48
SUBI4
ASGNI4
line 1235
;1235:		value = value * 10 + c;
ADDRLP4 4
CNSTI4 10
ADDRLP4 4
INDIRI4
MULI4
ADDRLP4 0
INDIRI4
ADDI4
ASGNI4
line 1236
;1236:	} while ( 1 );
LABELV $397
ADDRGP4 $396
JUMPV
LABELV $398
line 1240
;1237:
;1238:	// not handling 10e10 notation...
;1239:
;1240:	return value * sign;
ADDRLP4 4
INDIRI4
ADDRLP4 8
INDIRI4
MULI4
RETI4
LABELV $385
endproc atoi 28 0
export _atoi
proc _atoi 32 0
line 1244
;1241:}
;1242:
;1243:
;1244:int _atoi( const char **stringPtr ) {
line 1250
;1245:	int		sign;
;1246:	int		value;
;1247:	int		c;
;1248:	const char	*string;
;1249:
;1250:	string = *stringPtr;
ADDRLP4 4
ADDRFP4 0
INDIRP4
INDIRP4
ASGNP4
ADDRGP4 $404
JUMPV
LABELV $403
line 1253
;1251:
;1252:	// skip whitespace
;1253:	while ( *string <= ' ' ) {
line 1254
;1254:		if ( !*string ) {
ADDRLP4 4
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $406
line 1255
;1255:			return 0;
CNSTI4 0
RETI4
ADDRGP4 $402
JUMPV
LABELV $406
line 1257
;1256:		}
;1257:		string++;
ADDRLP4 4
ADDRLP4 4
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 1258
;1258:	}
LABELV $404
line 1253
ADDRLP4 4
INDIRP4
INDIRI1
CVII4 1
CNSTI4 32
LEI4 $403
line 1261
;1259:
;1260:	// check sign
;1261:	switch ( *string ) {
ADDRLP4 16
ADDRLP4 4
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 16
INDIRI4
CNSTI4 43
EQI4 $411
ADDRLP4 16
INDIRI4
CNSTI4 45
EQI4 $412
ADDRGP4 $408
JUMPV
LABELV $411
line 1263
;1262:	case '+':
;1263:		string++;
ADDRLP4 4
ADDRLP4 4
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 1264
;1264:		sign = 1;
ADDRLP4 12
CNSTI4 1
ASGNI4
line 1265
;1265:		break;
ADDRGP4 $409
JUMPV
LABELV $412
line 1267
;1266:	case '-':
;1267:		string++;
ADDRLP4 4
ADDRLP4 4
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 1268
;1268:		sign = -1;
ADDRLP4 12
CNSTI4 -1
ASGNI4
line 1269
;1269:		break;
ADDRGP4 $409
JUMPV
LABELV $408
line 1271
;1270:	default:
;1271:		sign = 1;
ADDRLP4 12
CNSTI4 1
ASGNI4
line 1272
;1272:		break;
LABELV $409
line 1276
;1273:	}
;1274:
;1275:	// read digits
;1276:	value = 0;
ADDRLP4 8
CNSTI4 0
ASGNI4
LABELV $413
line 1277
;1277:	do {
line 1278
;1278:		c = *string++;
ADDRLP4 24
ADDRLP4 4
INDIRP4
ASGNP4
ADDRLP4 4
ADDRLP4 24
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 0
ADDRLP4 24
INDIRP4
INDIRI1
CVII4 1
ASGNI4
line 1279
;1279:		if ( c < '0' || c > '9' ) {
ADDRLP4 0
INDIRI4
CNSTI4 48
LTI4 $418
ADDRLP4 0
INDIRI4
CNSTI4 57
LEI4 $416
LABELV $418
line 1280
;1280:			break;
ADDRGP4 $415
JUMPV
LABELV $416
line 1282
;1281:		}
;1282:		c -= '0';
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 48
SUBI4
ASGNI4
line 1283
;1283:		value = value * 10 + c;
ADDRLP4 8
CNSTI4 10
ADDRLP4 8
INDIRI4
MULI4
ADDRLP4 0
INDIRI4
ADDI4
ASGNI4
line 1284
;1284:	} while ( 1 );
LABELV $414
ADDRGP4 $413
JUMPV
LABELV $415
line 1288
;1285:
;1286:	// not handling 10e10 notation...
;1287:
;1288:	*stringPtr = string;
ADDRFP4 0
INDIRP4
ADDRLP4 4
INDIRP4
ASGNP4
line 1290
;1289:
;1290:	return value * sign;
ADDRLP4 8
INDIRI4
ADDRLP4 12
INDIRI4
MULI4
RETI4
LABELV $402
endproc _atoi 32 0
export strtol
proc strtol 32 0
line 1304
;1291:}
;1292:
;1293:/*
;1294:==============
;1295:strtol
;1296:
;1297:Handles any base from 2 to 36. If base is 0 then it guesses
;1298:decimal, hex, or octal based on the format of the number (leading 0 or 0x)
;1299:Will not overflow - returns LONG_MIN or LONG_MAX as appropriate
;1300:*endptr is set to the location of the first character not used
;1301:==============
;1302:*/
;1303:long strtol( const char *nptr, const char **endptr, int base )
;1304:{
line 1306
;1305:	long res;
;1306:	qboolean pos = qtrue;
ADDRLP4 4
CNSTI4 1
ASGNI4
line 1308
;1307:
;1308:	if( endptr )
ADDRFP4 4
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $420
line 1309
;1309:		*endptr = nptr;
ADDRFP4 4
INDIRP4
ADDRFP4 0
INDIRP4
ASGNP4
LABELV $420
line 1312
;1310:	// bases other than 0, 2, 8, 16 are very rarely used, but they're
;1311:	// not much extra effort to support
;1312:	if( base < 0 || base == 1 || base > 36 )
ADDRLP4 8
ADDRFP4 8
INDIRI4
ASGNI4
ADDRLP4 8
INDIRI4
CNSTI4 0
LTI4 $425
ADDRLP4 8
INDIRI4
CNSTI4 1
EQI4 $425
ADDRLP4 8
INDIRI4
CNSTI4 36
LEI4 $427
LABELV $425
line 1313
;1313:		return 0;
CNSTI4 0
RETI4
ADDRGP4 $419
JUMPV
LABELV $426
line 1316
;1314:	// skip leading whitespace
;1315:	while( isspace( *nptr ) )
;1316:		nptr++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
LABELV $427
line 1315
ADDRLP4 12
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 12
INDIRI4
CNSTI4 32
EQI4 $426
ADDRLP4 12
INDIRI4
CNSTI4 12
EQI4 $426
ADDRLP4 12
INDIRI4
CNSTI4 10
EQI4 $426
ADDRLP4 12
INDIRI4
CNSTI4 13
EQI4 $426
ADDRLP4 12
INDIRI4
CNSTI4 9
EQI4 $426
ADDRLP4 12
INDIRI4
CNSTI4 11
EQI4 $426
line 1318
;1317:	// sign
;1318:	if( *nptr == '-' )
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 45
NEI4 $429
line 1319
;1319:	{
line 1320
;1320:		nptr++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 1321
;1321:		pos = qfalse;
ADDRLP4 4
CNSTI4 0
ASGNI4
line 1322
;1322:	}
ADDRGP4 $430
JUMPV
LABELV $429
line 1323
;1323:	else if( *nptr == '+' )
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 43
NEI4 $431
line 1324
;1324:		nptr++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
LABELV $431
LABELV $430
line 1326
;1325:	// look for base-identifying sequences e.g. 0x for hex, 0 for octal
;1326:	if( nptr[0] == '0' )
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 48
NEI4 $433
line 1327
;1327:	{
line 1328
;1328:		nptr++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 1330
;1329:		// 0 is always a valid digit
;1330:		if( endptr )
ADDRFP4 4
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $435
line 1331
;1331:			*endptr = nptr;
ADDRFP4 4
INDIRP4
ADDRFP4 0
INDIRP4
ASGNP4
LABELV $435
line 1332
;1332:		if( *nptr == 'x' || *nptr == 'X' )
ADDRLP4 16
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 16
INDIRI4
CNSTI4 120
EQI4 $439
ADDRLP4 16
INDIRI4
CNSTI4 88
NEI4 $437
LABELV $439
line 1333
;1333:		{
line 1334
;1334:			if( base != 0 && base != 16 )
ADDRLP4 20
ADDRFP4 8
INDIRI4
ASGNI4
ADDRLP4 20
INDIRI4
CNSTI4 0
EQI4 $440
ADDRLP4 20
INDIRI4
CNSTI4 16
EQI4 $440
line 1335
;1335:			{
line 1337
;1336:				// can't be hex, reject x (accept 0)
;1337:				if( endptr )
ADDRFP4 4
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $442
line 1338
;1338:					*endptr = nptr;
ADDRFP4 4
INDIRP4
ADDRFP4 0
INDIRP4
ASGNP4
LABELV $442
line 1339
;1339:				return 0;
CNSTI4 0
RETI4
ADDRGP4 $419
JUMPV
LABELV $440
line 1341
;1340:			}
;1341:			nptr++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 1342
;1342:			base = 16;
ADDRFP4 8
CNSTI4 16
ASGNI4
line 1343
;1343:		}
ADDRGP4 $434
JUMPV
LABELV $437
line 1344
;1344:		else if( base == 0 )
ADDRFP4 8
INDIRI4
CNSTI4 0
NEI4 $434
line 1345
;1345:			base = 8;
ADDRFP4 8
CNSTI4 8
ASGNI4
line 1346
;1346:	}
ADDRGP4 $434
JUMPV
LABELV $433
line 1347
;1347:	else if( base == 0 )
ADDRFP4 8
INDIRI4
CNSTI4 0
NEI4 $446
line 1348
;1348:		base = 10;
ADDRFP4 8
CNSTI4 10
ASGNI4
LABELV $446
LABELV $434
line 1349
;1349:	res = 0;
ADDRLP4 0
CNSTI4 0
ASGNI4
ADDRGP4 $449
JUMPV
LABELV $448
line 1351
;1350:	while( qtrue )
;1351:	{
line 1353
;1352:		int val;
;1353:		if( isdigit( *nptr ) )
ADDRLP4 20
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 20
INDIRI4
CNSTI4 48
LTI4 $451
ADDRLP4 20
INDIRI4
CNSTI4 57
GTI4 $451
line 1354
;1354:			val = *nptr - '0';
ADDRLP4 16
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 48
SUBI4
ASGNI4
ADDRGP4 $452
JUMPV
LABELV $451
line 1355
;1355:		else if( islower( *nptr ) )
ADDRLP4 24
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 24
INDIRI4
CNSTI4 97
LTI4 $453
ADDRLP4 24
INDIRI4
CNSTI4 122
GTI4 $453
line 1356
;1356:			val = 10 + *nptr - 'a';
ADDRLP4 16
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 10
ADDI4
CNSTI4 97
SUBI4
ASGNI4
ADDRGP4 $454
JUMPV
LABELV $453
line 1357
;1357:		else if( isupper( *nptr ) )
ADDRLP4 28
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 28
INDIRI4
CNSTI4 65
LTI4 $450
ADDRLP4 28
INDIRI4
CNSTI4 90
GTI4 $450
line 1358
;1358:			val = 10 + *nptr - 'A';
ADDRLP4 16
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 10
ADDI4
CNSTI4 65
SUBI4
ASGNI4
line 1360
;1359:		else
;1360:			break;
LABELV $456
LABELV $454
LABELV $452
line 1361
;1361:		if( val >= base )
ADDRLP4 16
INDIRI4
ADDRFP4 8
INDIRI4
LTI4 $457
line 1362
;1362:			break;
ADDRGP4 $450
JUMPV
LABELV $457
line 1365
;1363:		// we go negative because LONG_MIN is further from 0 than
;1364:		// LONG_MAX
;1365:		if( res < ( LONG_MIN + val ) / base )
ADDRLP4 0
INDIRI4
ADDRLP4 16
INDIRI4
CNSTI4 -2147483648
ADDI4
ADDRFP4 8
INDIRI4
DIVI4
GEI4 $459
line 1366
;1366:			res = LONG_MIN; // overflow
ADDRLP4 0
CNSTI4 -2147483648
ASGNI4
ADDRGP4 $460
JUMPV
LABELV $459
line 1368
;1367:		else
;1368:			res = res * base - val;
ADDRLP4 0
ADDRLP4 0
INDIRI4
ADDRFP4 8
INDIRI4
MULI4
ADDRLP4 16
INDIRI4
SUBI4
ASGNI4
LABELV $460
line 1369
;1369:		nptr++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 1370
;1370:		if( endptr )
ADDRFP4 4
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $461
line 1371
;1371:			*endptr = nptr;
ADDRFP4 4
INDIRP4
ADDRFP4 0
INDIRP4
ASGNP4
LABELV $461
line 1372
;1372:	}
LABELV $449
line 1350
ADDRGP4 $448
JUMPV
LABELV $450
line 1373
;1373:	if( pos )
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $463
line 1374
;1374:	{
line 1376
;1375:		// can't represent LONG_MIN positive
;1376:		if( res == LONG_MIN )
ADDRLP4 0
INDIRI4
CNSTI4 -2147483648
NEI4 $465
line 1377
;1377:			res = LONG_MAX;
ADDRLP4 0
CNSTI4 2147483647
ASGNI4
ADDRGP4 $466
JUMPV
LABELV $465
line 1379
;1378:		else
;1379:			res = -res;
ADDRLP4 0
ADDRLP4 0
INDIRI4
NEGI4
ASGNI4
LABELV $466
line 1380
;1380:	}
LABELV $463
line 1381
;1381:	return res;
ADDRLP4 0
INDIRI4
RETI4
LABELV $419
endproc strtol 32 0
export abs
proc abs 4 0
line 1384
;1382:}
;1383:
;1384:int abs( int n ) {
line 1385
;1385:	return n < 0 ? -n : n;
ADDRFP4 0
INDIRI4
CNSTI4 0
GEI4 $469
ADDRLP4 0
ADDRFP4 0
INDIRI4
NEGI4
ASGNI4
ADDRGP4 $470
JUMPV
LABELV $469
ADDRLP4 0
ADDRFP4 0
INDIRI4
ASGNI4
LABELV $470
ADDRLP4 0
INDIRI4
RETI4
LABELV $467
endproc abs 4 0
export fabs
proc fabs 4 0
line 1388
;1386:}
;1387:
;1388:double fabs( double x ) {
line 1389
;1389:	return x < 0 ? -x : x;
ADDRFP4 0
INDIRF4
CNSTF4 0
GEF4 $473
ADDRLP4 0
ADDRFP4 0
INDIRF4
NEGF4
ASGNF4
ADDRGP4 $474
JUMPV
LABELV $473
ADDRLP4 0
ADDRFP4 0
INDIRF4
ASGNF4
LABELV $474
ADDRLP4 0
INDIRF4
RETF4
LABELV $471
endproc fabs 4 0
proc dopr 276 32
line 1528
;1390:}
;1391:
;1392:
;1393:
;1394://=========================================================
;1395:
;1396:/* 
;1397: * New implementation by Patrick Powell and others for vsnprintf.
;1398: * Supports length checking in strings.
;1399:*/
;1400:
;1401:/*
;1402: * Copyright Patrick Powell 1995
;1403: * This code is based on code written by Patrick Powell (papowell@astart.com)
;1404: * It may be used for any purpose as long as this notice remains intact
;1405: * on all source code distributions
;1406: */
;1407:
;1408:/**************************************************************
;1409: * Original:
;1410: * Patrick Powell Tue Apr 11 09:48:21 PDT 1995
;1411: * A bombproof version of doprnt (dopr) included.
;1412: * Sigh.  This sort of thing is always nasty do deal with.  Note that
;1413: * the version here does not include floating point...
;1414: *
;1415: * snprintf() is used instead of sprintf() as it does limit checks
;1416: * for string length.  This covers a nasty loophole.
;1417: *
;1418: * The other functions are there to prevent NULL pointers from
;1419: * causing nast effects.
;1420: *
;1421: * More Recently:
;1422: *  Brandon Long <blong@fiction.net> 9/15/96 for mutt 0.43
;1423: *  This was ugly.  It is still ugly.  I opted out of floating point
;1424: *  numbers, but the formatter understands just about everything
;1425: *  from the normal C string format, at least as far as I can tell from
;1426: *  the Solaris 2.5 printf(3S) man page.
;1427: *
;1428: *  Brandon Long <blong@fiction.net> 10/22/97 for mutt 0.87.1
;1429: *    Ok, added some minimal floating point support, which means this
;1430: *    probably requires libm on most operating systems.  Don't yet
;1431: *    support the exponent (e,E) and sigfig (g,G).  Also, fmtint()
;1432: *    was pretty badly broken, it just wasn't being exercised in ways
;1433: *    which showed it, so that's been fixed.  Also, formated the code
;1434: *    to mutt conventions, and removed dead code left over from the
;1435: *    original.  Also, there is now a builtin-test, just compile with:
;1436: *           gcc -DTEST_SNPRINTF -o snprintf snprintf.c -lm
;1437: *    and run snprintf for results.
;1438: * 
;1439: *  Thomas Roessler <roessler@guug.de> 01/27/98 for mutt 0.89i
;1440: *    The PGP code was using unsigned hexadecimal formats. 
;1441: *    Unfortunately, unsigned formats simply didn't work.
;1442: *
;1443: *  Michael Elkins <me@cs.hmc.edu> 03/05/98 for mutt 0.90.8
;1444: *    The original code assumed that both snprintf() and vsnprintf() were
;1445: *    missing.  Some systems only have snprintf() but not vsnprintf(), so
;1446: *    the code is now broken down under HAVE_SNPRINTF and HAVE_VSNPRINTF.
;1447: *
;1448: *  Andrew Tridgell (tridge@samba.org) Oct 1998
;1449: *    fixed handling of %.0f
;1450: *    added test for HAVE_LONG_DOUBLE
;1451: *
;1452: *  Russ Allbery <rra@stanford.edu> 2000-08-26
;1453: *    fixed return value to comply with C99
;1454: *    fixed handling of snprintf(NULL, ...)
;1455: *
;1456: *  Hrvoje Niksic <hniksic@arsdigita.com> 2000-11-04
;1457: *    include <config.h> instead of "config.h".
;1458: *    moved TEST_SNPRINTF stuff out of HAVE_SNPRINTF ifdef.
;1459: *    include <stdio.h> for NULL.
;1460: *    added support and test cases for long long.
;1461: *    don't declare argument types to (v)snprintf if stdarg is not used.
;1462: *    use int instead of short int as 2nd arg to va_arg.
;1463: *
;1464: **************************************************************/
;1465:
;1466:/* BDR 2002-01-13  %e and %g were being ignored.  Now do something,
;1467:   if not necessarily correctly */
;1468:
;1469:#if (SIZEOF_LONG_DOUBLE > 0)
;1470:/* #ifdef HAVE_LONG_DOUBLE */
;1471:#define LDOUBLE long double
;1472:#else
;1473:#define LDOUBLE double
;1474:#endif
;1475:
;1476:#if (SIZEOF_LONG_LONG > 0)
;1477:/* #ifdef HAVE_LONG_LONG */
;1478:# define LLONG long long
;1479:#else
;1480:# define LLONG long
;1481:#endif
;1482:
;1483:static int dopr (char *buffer, size_t maxlen, const char *format, 
;1484:                 va_list args);
;1485:static int fmtstr (char *buffer, size_t *currlen, size_t maxlen,
;1486:		   char *value, int flags, int min, int max);
;1487:static int fmtint (char *buffer, size_t *currlen, size_t maxlen,
;1488:		   LLONG value, int base, int min, int max, int flags);
;1489:static int fmtfp (char *buffer, size_t *currlen, size_t maxlen,
;1490:		  LDOUBLE fvalue, int min, int max, int flags);
;1491:static int dopr_outch (char *buffer, size_t *currlen, size_t maxlen, char c );
;1492:
;1493:/*
;1494: * dopr(): poor man's version of doprintf
;1495: */
;1496:
;1497:/* format read states */
;1498:#define DP_S_DEFAULT 0
;1499:#define DP_S_FLAGS   1
;1500:#define DP_S_MIN     2
;1501:#define DP_S_DOT     3
;1502:#define DP_S_MAX     4
;1503:#define DP_S_MOD     5
;1504:#define DP_S_MOD_L   6
;1505:#define DP_S_CONV    7
;1506:#define DP_S_DONE    8
;1507:
;1508:/* format flags - Bits */
;1509:#define DP_F_MINUS 	(1 << 0)
;1510:#define DP_F_PLUS  	(1 << 1)
;1511:#define DP_F_SPACE 	(1 << 2)
;1512:#define DP_F_NUM   	(1 << 3)
;1513:#define DP_F_ZERO  	(1 << 4)
;1514:#define DP_F_UP    	(1 << 5)
;1515:#define DP_F_UNSIGNED 	(1 << 6)
;1516:
;1517:/* Conversion Flags */
;1518:#define DP_C_SHORT   1
;1519:#define DP_C_LONG    2
;1520:#define DP_C_LLONG   3
;1521:#define DP_C_LDOUBLE 4
;1522:
;1523:#define char_to_int(p) (p - '0')
;1524:#define MAX(p,q) ((p >= q) ? p : q)
;1525:#define MIN(p,q) ((p <= q) ? p : q)
;1526:
;1527:static int dopr (char *buffer, size_t maxlen, const char *format, va_list args)
;1528:{
line 1541
;1529:  char ch;
;1530:  LLONG value;
;1531:  LDOUBLE fvalue;
;1532:  char *strvalue;
;1533:  int min;
;1534:  int max;
;1535:  int state;
;1536:  int flags;
;1537:  int cflags;
;1538:  int total;
;1539:  size_t currlen;
;1540:  
;1541:  state = DP_S_DEFAULT;
ADDRLP4 0
CNSTI4 0
ASGNI4
line 1542
;1542:  currlen = flags = cflags = min = 0;
ADDRLP4 44
CNSTI4 0
ASGNI4
ADDRLP4 16
ADDRLP4 44
INDIRI4
ASGNI4
ADDRLP4 12
ADDRLP4 44
INDIRI4
ASGNI4
ADDRLP4 20
ADDRLP4 44
INDIRI4
ASGNI4
ADDRLP4 28
ADDRLP4 44
INDIRI4
ASGNI4
line 1543
;1543:  max = -1;
ADDRLP4 8
CNSTI4 -1
ASGNI4
line 1544
;1544:  ch = *format++;
ADDRLP4 48
ADDRFP4 8
INDIRP4
ASGNP4
ADDRFP4 8
ADDRLP4 48
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 4
ADDRLP4 48
INDIRP4
INDIRI1
ASGNI1
line 1545
;1545:  total = 0;
ADDRLP4 24
CNSTI4 0
ASGNI4
ADDRGP4 $477
JUMPV
LABELV $476
line 1548
;1546:
;1547:  while (state != DP_S_DONE)
;1548:  {
line 1549
;1549:    if (ch == '\0')
ADDRLP4 4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $479
line 1550
;1550:      state = DP_S_DONE;
ADDRLP4 0
CNSTI4 8
ASGNI4
LABELV $479
line 1552
;1551:
;1552:    switch(state) 
ADDRLP4 0
INDIRI4
CNSTI4 0
LTI4 $482
ADDRLP4 0
INDIRI4
CNSTI4 8
GTI4 $482
ADDRLP4 0
INDIRI4
CNSTI4 2
LSHI4
ADDRGP4 $589
ADDP4
INDIRP4
JUMPV
lit
align 4
LABELV $589
address $483
address $486
address $496
address $501
address $504
address $511
address $522
address $527
address $482
code
line 1553
;1553:    {
LABELV $483
line 1555
;1554:    case DP_S_DEFAULT:
;1555:      if (ch == '%') 
ADDRLP4 4
INDIRI1
CVII4 1
CNSTI4 37
NEI4 $484
line 1556
;1556:	state = DP_S_FLAGS;
ADDRLP4 0
CNSTI4 1
ASGNI4
ADDRGP4 $485
JUMPV
LABELV $484
line 1558
;1557:      else 
;1558:	total += dopr_outch (buffer, &currlen, maxlen, ch);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 28
ARGP4
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 4
INDIRI1
CVII4 1
ARGI4
ADDRLP4 56
ADDRGP4 dopr_outch
CALLI4
ASGNI4
ADDRLP4 24
ADDRLP4 24
INDIRI4
ADDRLP4 56
INDIRI4
ADDI4
ASGNI4
LABELV $485
line 1559
;1559:      ch = *format++;
ADDRLP4 60
ADDRFP4 8
INDIRP4
ASGNP4
ADDRFP4 8
ADDRLP4 60
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 4
ADDRLP4 60
INDIRP4
INDIRI1
ASGNI1
line 1560
;1560:      break;
ADDRGP4 $482
JUMPV
LABELV $486
line 1562
;1561:    case DP_S_FLAGS:
;1562:      switch (ch) 
ADDRLP4 64
ADDRLP4 4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 72
CNSTI4 32
ASGNI4
ADDRLP4 64
INDIRI4
ADDRLP4 72
INDIRI4
EQI4 $492
ADDRLP4 64
INDIRI4
CNSTI4 35
EQI4 $493
ADDRLP4 64
INDIRI4
ADDRLP4 72
INDIRI4
LTI4 $487
LABELV $495
ADDRLP4 64
INDIRI4
CNSTI4 43
EQI4 $491
ADDRLP4 64
INDIRI4
CNSTI4 45
EQI4 $490
ADDRLP4 64
INDIRI4
CNSTI4 48
EQI4 $494
ADDRGP4 $487
JUMPV
line 1563
;1563:      {
LABELV $490
line 1565
;1564:      case '-':
;1565:	flags |= DP_F_MINUS;
ADDRLP4 20
ADDRLP4 20
INDIRI4
CNSTI4 1
BORI4
ASGNI4
line 1566
;1566:        ch = *format++;
ADDRLP4 80
ADDRFP4 8
INDIRP4
ASGNP4
ADDRFP4 8
ADDRLP4 80
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 4
ADDRLP4 80
INDIRP4
INDIRI1
ASGNI1
line 1567
;1567:	break;
ADDRGP4 $482
JUMPV
LABELV $491
line 1569
;1568:      case '+':
;1569:	flags |= DP_F_PLUS;
ADDRLP4 20
ADDRLP4 20
INDIRI4
CNSTI4 2
BORI4
ASGNI4
line 1570
;1570:        ch = *format++;
ADDRLP4 84
ADDRFP4 8
INDIRP4
ASGNP4
ADDRFP4 8
ADDRLP4 84
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 4
ADDRLP4 84
INDIRP4
INDIRI1
ASGNI1
line 1571
;1571:	break;
ADDRGP4 $482
JUMPV
LABELV $492
line 1573
;1572:      case ' ':
;1573:	flags |= DP_F_SPACE;
ADDRLP4 20
ADDRLP4 20
INDIRI4
CNSTI4 4
BORI4
ASGNI4
line 1574
;1574:        ch = *format++;
ADDRLP4 88
ADDRFP4 8
INDIRP4
ASGNP4
ADDRFP4 8
ADDRLP4 88
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 4
ADDRLP4 88
INDIRP4
INDIRI1
ASGNI1
line 1575
;1575:	break;
ADDRGP4 $482
JUMPV
LABELV $493
line 1577
;1576:      case '#':
;1577:	flags |= DP_F_NUM;
ADDRLP4 20
ADDRLP4 20
INDIRI4
CNSTI4 8
BORI4
ASGNI4
line 1578
;1578:        ch = *format++;
ADDRLP4 92
ADDRFP4 8
INDIRP4
ASGNP4
ADDRFP4 8
ADDRLP4 92
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 4
ADDRLP4 92
INDIRP4
INDIRI1
ASGNI1
line 1579
;1579:	break;
ADDRGP4 $482
JUMPV
LABELV $494
line 1581
;1580:      case '0':
;1581:	flags |= DP_F_ZERO;
ADDRLP4 20
ADDRLP4 20
INDIRI4
CNSTI4 16
BORI4
ASGNI4
line 1582
;1582:        ch = *format++;
ADDRLP4 96
ADDRFP4 8
INDIRP4
ASGNP4
ADDRFP4 8
ADDRLP4 96
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 4
ADDRLP4 96
INDIRP4
INDIRI1
ASGNI1
line 1583
;1583:	break;
ADDRGP4 $482
JUMPV
LABELV $487
line 1585
;1584:      default:
;1585:	state = DP_S_MIN;
ADDRLP4 0
CNSTI4 2
ASGNI4
line 1586
;1586:	break;
line 1588
;1587:      }
;1588:      break;
ADDRGP4 $482
JUMPV
LABELV $496
line 1590
;1589:    case DP_S_MIN:
;1590:      if ('0' <= ch && ch <= '9')
ADDRLP4 80
ADDRLP4 4
INDIRI1
CVII4 1
ASGNI4
CNSTI4 48
ADDRLP4 80
INDIRI4
GTI4 $497
ADDRLP4 80
INDIRI4
CNSTI4 57
GTI4 $497
line 1591
;1591:      {
line 1592
;1592:	min = 10*min + char_to_int (ch);
ADDRLP4 16
CNSTI4 10
ADDRLP4 16
INDIRI4
MULI4
ADDRLP4 4
INDIRI1
CVII4 1
CNSTI4 48
SUBI4
ADDI4
ASGNI4
line 1593
;1593:	ch = *format++;
ADDRLP4 84
ADDRFP4 8
INDIRP4
ASGNP4
ADDRFP4 8
ADDRLP4 84
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 4
ADDRLP4 84
INDIRP4
INDIRI1
ASGNI1
line 1594
;1594:      } 
ADDRGP4 $482
JUMPV
LABELV $497
line 1595
;1595:      else if (ch == '*') 
ADDRLP4 4
INDIRI1
CVII4 1
CNSTI4 42
NEI4 $499
line 1596
;1596:      {
line 1597
;1597:	min = va_arg (args, int);
ADDRLP4 84
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 84
INDIRP4
ASGNP4
ADDRLP4 16
ADDRLP4 84
INDIRP4
CNSTI4 -4
ADDP4
INDIRI4
ASGNI4
line 1598
;1598:	ch = *format++;
ADDRLP4 88
ADDRFP4 8
INDIRP4
ASGNP4
ADDRFP4 8
ADDRLP4 88
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 4
ADDRLP4 88
INDIRP4
INDIRI1
ASGNI1
line 1599
;1599:	state = DP_S_DOT;
ADDRLP4 0
CNSTI4 3
ASGNI4
line 1600
;1600:      } 
ADDRGP4 $482
JUMPV
LABELV $499
line 1602
;1601:      else 
;1602:	state = DP_S_DOT;
ADDRLP4 0
CNSTI4 3
ASGNI4
line 1603
;1603:      break;
ADDRGP4 $482
JUMPV
LABELV $501
line 1605
;1604:    case DP_S_DOT:
;1605:      if (ch == '.') 
ADDRLP4 4
INDIRI1
CVII4 1
CNSTI4 46
NEI4 $502
line 1606
;1606:      {
line 1607
;1607:	state = DP_S_MAX;
ADDRLP4 0
CNSTI4 4
ASGNI4
line 1608
;1608:	ch = *format++;
ADDRLP4 84
ADDRFP4 8
INDIRP4
ASGNP4
ADDRFP4 8
ADDRLP4 84
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 4
ADDRLP4 84
INDIRP4
INDIRI1
ASGNI1
line 1609
;1609:      } 
ADDRGP4 $482
JUMPV
LABELV $502
line 1611
;1610:      else 
;1611:	state = DP_S_MOD;
ADDRLP4 0
CNSTI4 5
ASGNI4
line 1612
;1612:      break;
ADDRGP4 $482
JUMPV
LABELV $504
line 1614
;1613:    case DP_S_MAX:
;1614:      if ('0' <= ch && ch <= '9')
ADDRLP4 84
ADDRLP4 4
INDIRI1
CVII4 1
ASGNI4
CNSTI4 48
ADDRLP4 84
INDIRI4
GTI4 $505
ADDRLP4 84
INDIRI4
CNSTI4 57
GTI4 $505
line 1615
;1615:      {
line 1616
;1616:	if (max < 0)
ADDRLP4 8
INDIRI4
CNSTI4 0
GEI4 $507
line 1617
;1617:	  max = 0;
ADDRLP4 8
CNSTI4 0
ASGNI4
LABELV $507
line 1618
;1618:	max = 10*max + char_to_int (ch);
ADDRLP4 8
CNSTI4 10
ADDRLP4 8
INDIRI4
MULI4
ADDRLP4 4
INDIRI1
CVII4 1
CNSTI4 48
SUBI4
ADDI4
ASGNI4
line 1619
;1619:	ch = *format++;
ADDRLP4 88
ADDRFP4 8
INDIRP4
ASGNP4
ADDRFP4 8
ADDRLP4 88
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 4
ADDRLP4 88
INDIRP4
INDIRI1
ASGNI1
line 1620
;1620:      } 
ADDRGP4 $482
JUMPV
LABELV $505
line 1621
;1621:      else if (ch == '*') 
ADDRLP4 4
INDIRI1
CVII4 1
CNSTI4 42
NEI4 $509
line 1622
;1622:      {
line 1623
;1623:	max = va_arg (args, int);
ADDRLP4 88
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 88
INDIRP4
ASGNP4
ADDRLP4 8
ADDRLP4 88
INDIRP4
CNSTI4 -4
ADDP4
INDIRI4
ASGNI4
line 1624
;1624:	ch = *format++;
ADDRLP4 92
ADDRFP4 8
INDIRP4
ASGNP4
ADDRFP4 8
ADDRLP4 92
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 4
ADDRLP4 92
INDIRP4
INDIRI1
ASGNI1
line 1625
;1625:	state = DP_S_MOD;
ADDRLP4 0
CNSTI4 5
ASGNI4
line 1626
;1626:      } 
ADDRGP4 $482
JUMPV
LABELV $509
line 1628
;1627:      else 
;1628:	state = DP_S_MOD;
ADDRLP4 0
CNSTI4 5
ASGNI4
line 1629
;1629:      break;
ADDRGP4 $482
JUMPV
LABELV $511
line 1631
;1630:    case DP_S_MOD:
;1631:      switch (ch) 
ADDRLP4 88
ADDRLP4 4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 96
CNSTI4 104
ASGNI4
ADDRLP4 88
INDIRI4
ADDRLP4 96
INDIRI4
EQI4 $515
ADDRLP4 88
INDIRI4
ADDRLP4 96
INDIRI4
GTI4 $519
LABELV $518
ADDRLP4 88
INDIRI4
CNSTI4 76
EQI4 $517
ADDRGP4 $513
JUMPV
LABELV $519
ADDRLP4 88
INDIRI4
CNSTI4 108
EQI4 $516
ADDRGP4 $513
JUMPV
line 1632
;1632:      {
LABELV $515
line 1634
;1633:      case 'h':
;1634:	cflags = DP_C_SHORT;
ADDRLP4 12
CNSTI4 1
ASGNI4
line 1635
;1635:	ch = *format++;
ADDRLP4 100
ADDRFP4 8
INDIRP4
ASGNP4
ADDRFP4 8
ADDRLP4 100
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 4
ADDRLP4 100
INDIRP4
INDIRI1
ASGNI1
line 1636
;1636:	break;
ADDRGP4 $513
JUMPV
LABELV $516
line 1638
;1637:      case 'l':
;1638:	cflags = DP_C_LONG;
ADDRLP4 12
CNSTI4 2
ASGNI4
line 1639
;1639:	ch = *format++;
ADDRLP4 104
ADDRFP4 8
INDIRP4
ASGNP4
ADDRFP4 8
ADDRLP4 104
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 4
ADDRLP4 104
INDIRP4
INDIRI1
ASGNI1
line 1640
;1640:	break;
ADDRGP4 $513
JUMPV
LABELV $517
line 1642
;1641:      case 'L':
;1642:	cflags = DP_C_LDOUBLE;
ADDRLP4 12
CNSTI4 4
ASGNI4
line 1643
;1643:	ch = *format++;
ADDRLP4 108
ADDRFP4 8
INDIRP4
ASGNP4
ADDRFP4 8
ADDRLP4 108
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 4
ADDRLP4 108
INDIRP4
INDIRI1
ASGNI1
line 1644
;1644:	break;
line 1646
;1645:      default:
;1646:	break;
LABELV $513
line 1648
;1647:      }
;1648:      if (cflags != DP_C_LONG)
ADDRLP4 12
INDIRI4
CNSTI4 2
EQI4 $520
line 1649
;1649:	state = DP_S_CONV;
ADDRLP4 0
CNSTI4 7
ASGNI4
ADDRGP4 $482
JUMPV
LABELV $520
line 1651
;1650:      else
;1651:	state = DP_S_MOD_L;
ADDRLP4 0
CNSTI4 6
ASGNI4
line 1652
;1652:      break;
ADDRGP4 $482
JUMPV
LABELV $522
line 1654
;1653:    case DP_S_MOD_L:
;1654:      switch (ch)
ADDRLP4 100
ADDRLP4 4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 100
INDIRI4
CNSTI4 108
EQI4 $526
ADDRGP4 $524
JUMPV
line 1655
;1655:	{
LABELV $526
line 1657
;1656:	case 'l':
;1657:	  cflags = DP_C_LLONG;
ADDRLP4 12
CNSTI4 3
ASGNI4
line 1658
;1658:	  ch = *format++;
ADDRLP4 104
ADDRFP4 8
INDIRP4
ASGNP4
ADDRFP4 8
ADDRLP4 104
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 4
ADDRLP4 104
INDIRP4
INDIRI1
ASGNI1
line 1659
;1659:	  break;
line 1661
;1660:	default:
;1661:	  break;
LABELV $524
line 1663
;1662:	}
;1663:      state = DP_S_CONV;
ADDRLP4 0
CNSTI4 7
ASGNI4
line 1664
;1664:      break;
ADDRGP4 $482
JUMPV
LABELV $527
line 1666
;1665:    case DP_S_CONV:
;1666:      switch (ch) 
ADDRLP4 104
ADDRLP4 4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 104
INDIRI4
CNSTI4 69
EQI4 $563
ADDRLP4 112
CNSTI4 71
ASGNI4
ADDRLP4 104
INDIRI4
ADDRLP4 112
INDIRI4
EQI4 $567
ADDRLP4 104
INDIRI4
ADDRLP4 112
INDIRI4
GTI4 $584
LABELV $583
ADDRLP4 104
INDIRI4
CNSTI4 37
EQI4 $581
ADDRGP4 $529
JUMPV
LABELV $584
ADDRLP4 120
CNSTI4 88
ASGNI4
ADDRLP4 104
INDIRI4
ADDRLP4 120
INDIRI4
EQI4 $552
ADDRLP4 104
INDIRI4
ADDRLP4 120
INDIRI4
LTI4 $529
LABELV $585
ADDRLP4 104
INDIRI4
CNSTI4 99
LTI4 $529
ADDRLP4 104
INDIRI4
CNSTI4 120
GTI4 $529
ADDRLP4 104
INDIRI4
CNSTI4 2
LSHI4
ADDRGP4 $586-396
ADDP4
INDIRP4
JUMPV
lit
align 4
LABELV $586
address $571
address $531
address $564
address $560
address $568
address $529
address $531
address $529
address $529
address $529
address $529
address $574
address $538
address $573
address $529
address $529
address $572
address $529
address $545
address $529
address $582
address $553
code
line 1667
;1667:      {
LABELV $531
line 1670
;1668:      case 'd':
;1669:      case 'i':
;1670:	if (cflags == DP_C_SHORT) 
ADDRLP4 12
INDIRI4
CNSTI4 1
NEI4 $532
line 1671
;1671:	  value = (short int)va_arg (args, int);
ADDRLP4 128
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 128
INDIRP4
ASGNP4
ADDRLP4 32
ADDRLP4 128
INDIRP4
CNSTI4 -4
ADDP4
INDIRI4
CVII2 4
CVII4 2
ASGNI4
ADDRGP4 $533
JUMPV
LABELV $532
line 1672
;1672:	else if (cflags == DP_C_LONG)
ADDRLP4 12
INDIRI4
CNSTI4 2
NEI4 $534
line 1673
;1673:	  value = va_arg (args, long int);
ADDRLP4 132
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 132
INDIRP4
ASGNP4
ADDRLP4 32
ADDRLP4 132
INDIRP4
CNSTI4 -4
ADDP4
INDIRI4
ASGNI4
ADDRGP4 $535
JUMPV
LABELV $534
line 1674
;1674:	else if (cflags == DP_C_LLONG)
ADDRLP4 12
INDIRI4
CNSTI4 3
NEI4 $536
line 1675
;1675:	  value = va_arg (args, LLONG);
ADDRLP4 136
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 136
INDIRP4
ASGNP4
ADDRLP4 32
ADDRLP4 136
INDIRP4
CNSTI4 -4
ADDP4
INDIRI4
ASGNI4
ADDRGP4 $537
JUMPV
LABELV $536
line 1677
;1676:	else
;1677:	  value = va_arg (args, int);
ADDRLP4 140
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 140
INDIRP4
ASGNP4
ADDRLP4 32
ADDRLP4 140
INDIRP4
CNSTI4 -4
ADDP4
INDIRI4
ASGNI4
LABELV $537
LABELV $535
LABELV $533
line 1678
;1678:	total += fmtint (buffer, &currlen, maxlen, value, 10, min, max, flags);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 28
ARGP4
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 32
INDIRI4
ARGI4
CNSTI4 10
ARGI4
ADDRLP4 16
INDIRI4
ARGI4
ADDRLP4 8
INDIRI4
ARGI4
ADDRLP4 20
INDIRI4
ARGI4
ADDRLP4 144
ADDRGP4 fmtint
CALLI4
ASGNI4
ADDRLP4 24
ADDRLP4 24
INDIRI4
ADDRLP4 144
INDIRI4
ADDI4
ASGNI4
line 1679
;1679:	break;
ADDRGP4 $529
JUMPV
LABELV $538
line 1681
;1680:      case 'o':
;1681:	flags |= DP_F_UNSIGNED;
ADDRLP4 20
ADDRLP4 20
INDIRI4
CNSTI4 64
BORI4
ASGNI4
line 1682
;1682:	if (cflags == DP_C_SHORT)
ADDRLP4 12
INDIRI4
CNSTI4 1
NEI4 $539
line 1684
;1683://	  value = (unsigned short int) va_arg (args, unsigned short int); // Thilo: This does not work because the rcc compiler cannot do that cast correctly.
;1684:	  value = va_arg (args, unsigned int) & ( (1 << sizeof(unsigned short int) * 8) - 1); // Using this workaround instead.
ADDRLP4 148
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 148
INDIRP4
ASGNP4
ADDRLP4 32
ADDRLP4 148
INDIRP4
CNSTI4 -4
ADDP4
INDIRU4
CNSTU4 65535
BANDU4
CVUI4 4
ASGNI4
ADDRGP4 $540
JUMPV
LABELV $539
line 1685
;1685:	else if (cflags == DP_C_LONG)
ADDRLP4 12
INDIRI4
CNSTI4 2
NEI4 $541
line 1686
;1686:	  value = va_arg (args, unsigned long int);
ADDRLP4 152
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 152
INDIRP4
ASGNP4
ADDRLP4 32
ADDRLP4 152
INDIRP4
CNSTI4 -4
ADDP4
INDIRU4
CVUI4 4
ASGNI4
ADDRGP4 $542
JUMPV
LABELV $541
line 1687
;1687:	else if (cflags == DP_C_LLONG)
ADDRLP4 12
INDIRI4
CNSTI4 3
NEI4 $543
line 1688
;1688:	  value = va_arg (args, unsigned LLONG);
ADDRLP4 156
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 156
INDIRP4
ASGNP4
ADDRLP4 32
ADDRLP4 156
INDIRP4
CNSTI4 -4
ADDP4
INDIRU4
CVUI4 4
ASGNI4
ADDRGP4 $544
JUMPV
LABELV $543
line 1690
;1689:	else
;1690:	  value = va_arg (args, unsigned int);
ADDRLP4 160
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 160
INDIRP4
ASGNP4
ADDRLP4 32
ADDRLP4 160
INDIRP4
CNSTI4 -4
ADDP4
INDIRU4
CVUI4 4
ASGNI4
LABELV $544
LABELV $542
LABELV $540
line 1691
;1691:	total += fmtint (buffer, &currlen, maxlen, value, 8, min, max, flags);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 28
ARGP4
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 32
INDIRI4
ARGI4
CNSTI4 8
ARGI4
ADDRLP4 16
INDIRI4
ARGI4
ADDRLP4 8
INDIRI4
ARGI4
ADDRLP4 20
INDIRI4
ARGI4
ADDRLP4 164
ADDRGP4 fmtint
CALLI4
ASGNI4
ADDRLP4 24
ADDRLP4 24
INDIRI4
ADDRLP4 164
INDIRI4
ADDI4
ASGNI4
line 1692
;1692:	break;
ADDRGP4 $529
JUMPV
LABELV $545
line 1694
;1693:      case 'u':
;1694:	flags |= DP_F_UNSIGNED;
ADDRLP4 20
ADDRLP4 20
INDIRI4
CNSTI4 64
BORI4
ASGNI4
line 1695
;1695:	if (cflags == DP_C_SHORT)
ADDRLP4 12
INDIRI4
CNSTI4 1
NEI4 $546
line 1696
;1696:	  value = va_arg (args, unsigned int) & ( (1 << sizeof(unsigned short int) * 8) - 1);
ADDRLP4 168
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 168
INDIRP4
ASGNP4
ADDRLP4 32
ADDRLP4 168
INDIRP4
CNSTI4 -4
ADDP4
INDIRU4
CNSTU4 65535
BANDU4
CVUI4 4
ASGNI4
ADDRGP4 $547
JUMPV
LABELV $546
line 1697
;1697:	else if (cflags == DP_C_LONG)
ADDRLP4 12
INDIRI4
CNSTI4 2
NEI4 $548
line 1698
;1698:	  value = va_arg (args, unsigned long int);
ADDRLP4 172
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 172
INDIRP4
ASGNP4
ADDRLP4 32
ADDRLP4 172
INDIRP4
CNSTI4 -4
ADDP4
INDIRU4
CVUI4 4
ASGNI4
ADDRGP4 $549
JUMPV
LABELV $548
line 1699
;1699:	else if (cflags == DP_C_LLONG)
ADDRLP4 12
INDIRI4
CNSTI4 3
NEI4 $550
line 1700
;1700:	  value = va_arg (args, unsigned LLONG);
ADDRLP4 176
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 176
INDIRP4
ASGNP4
ADDRLP4 32
ADDRLP4 176
INDIRP4
CNSTI4 -4
ADDP4
INDIRU4
CVUI4 4
ASGNI4
ADDRGP4 $551
JUMPV
LABELV $550
line 1702
;1701:	else
;1702:	  value = va_arg (args, unsigned int);
ADDRLP4 180
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 180
INDIRP4
ASGNP4
ADDRLP4 32
ADDRLP4 180
INDIRP4
CNSTI4 -4
ADDP4
INDIRU4
CVUI4 4
ASGNI4
LABELV $551
LABELV $549
LABELV $547
line 1703
;1703:	total += fmtint (buffer, &currlen, maxlen, value, 10, min, max, flags);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 28
ARGP4
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 32
INDIRI4
ARGI4
CNSTI4 10
ARGI4
ADDRLP4 16
INDIRI4
ARGI4
ADDRLP4 8
INDIRI4
ARGI4
ADDRLP4 20
INDIRI4
ARGI4
ADDRLP4 184
ADDRGP4 fmtint
CALLI4
ASGNI4
ADDRLP4 24
ADDRLP4 24
INDIRI4
ADDRLP4 184
INDIRI4
ADDI4
ASGNI4
line 1704
;1704:	break;
ADDRGP4 $529
JUMPV
LABELV $552
line 1706
;1705:      case 'X':
;1706:	flags |= DP_F_UP;
ADDRLP4 20
ADDRLP4 20
INDIRI4
CNSTI4 32
BORI4
ASGNI4
LABELV $553
line 1708
;1707:      case 'x':
;1708:	flags |= DP_F_UNSIGNED;
ADDRLP4 20
ADDRLP4 20
INDIRI4
CNSTI4 64
BORI4
ASGNI4
line 1709
;1709:	if (cflags == DP_C_SHORT)
ADDRLP4 12
INDIRI4
CNSTI4 1
NEI4 $554
line 1710
;1710:	  value = va_arg (args, unsigned int) & ( (1 << sizeof(unsigned short int) * 8) - 1);
ADDRLP4 188
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 188
INDIRP4
ASGNP4
ADDRLP4 32
ADDRLP4 188
INDIRP4
CNSTI4 -4
ADDP4
INDIRU4
CNSTU4 65535
BANDU4
CVUI4 4
ASGNI4
ADDRGP4 $555
JUMPV
LABELV $554
line 1711
;1711:	else if (cflags == DP_C_LONG)
ADDRLP4 12
INDIRI4
CNSTI4 2
NEI4 $556
line 1712
;1712:	  value = va_arg (args, unsigned long int);
ADDRLP4 192
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 192
INDIRP4
ASGNP4
ADDRLP4 32
ADDRLP4 192
INDIRP4
CNSTI4 -4
ADDP4
INDIRU4
CVUI4 4
ASGNI4
ADDRGP4 $557
JUMPV
LABELV $556
line 1713
;1713:	else if (cflags == DP_C_LLONG)
ADDRLP4 12
INDIRI4
CNSTI4 3
NEI4 $558
line 1714
;1714:	  value = va_arg (args, unsigned LLONG);
ADDRLP4 196
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 196
INDIRP4
ASGNP4
ADDRLP4 32
ADDRLP4 196
INDIRP4
CNSTI4 -4
ADDP4
INDIRU4
CVUI4 4
ASGNI4
ADDRGP4 $559
JUMPV
LABELV $558
line 1716
;1715:	else
;1716:	  value = va_arg (args, unsigned int);
ADDRLP4 200
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 200
INDIRP4
ASGNP4
ADDRLP4 32
ADDRLP4 200
INDIRP4
CNSTI4 -4
ADDP4
INDIRU4
CVUI4 4
ASGNI4
LABELV $559
LABELV $557
LABELV $555
line 1717
;1717:	total += fmtint (buffer, &currlen, maxlen, value, 16, min, max, flags);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 28
ARGP4
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 32
INDIRI4
ARGI4
CNSTI4 16
ARGI4
ADDRLP4 16
INDIRI4
ARGI4
ADDRLP4 8
INDIRI4
ARGI4
ADDRLP4 20
INDIRI4
ARGI4
ADDRLP4 204
ADDRGP4 fmtint
CALLI4
ASGNI4
ADDRLP4 24
ADDRLP4 24
INDIRI4
ADDRLP4 204
INDIRI4
ADDI4
ASGNI4
line 1718
;1718:	break;
ADDRGP4 $529
JUMPV
LABELV $560
line 1720
;1719:      case 'f':
;1720:	if (cflags == DP_C_LDOUBLE)
ADDRLP4 12
INDIRI4
CNSTI4 4
NEI4 $561
line 1721
;1721:	  fvalue = va_arg (args, LDOUBLE);
ADDRLP4 208
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 208
INDIRP4
ASGNP4
ADDRLP4 36
ADDRLP4 208
INDIRP4
CNSTI4 -4
ADDP4
INDIRF4
ASGNF4
ADDRGP4 $562
JUMPV
LABELV $561
line 1723
;1722:	else
;1723:	  fvalue = va_arg (args, double);
ADDRLP4 212
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 212
INDIRP4
ASGNP4
ADDRLP4 36
ADDRLP4 212
INDIRP4
CNSTI4 -4
ADDP4
INDIRF4
ASGNF4
LABELV $562
line 1725
;1724:	/* um, floating point? */
;1725:	total += fmtfp (buffer, &currlen, maxlen, fvalue, min, max, flags);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 28
ARGP4
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 36
INDIRF4
ARGF4
ADDRLP4 16
INDIRI4
ARGI4
ADDRLP4 8
INDIRI4
ARGI4
ADDRLP4 20
INDIRI4
ARGI4
ADDRLP4 216
ADDRGP4 fmtfp
CALLI4
ASGNI4
ADDRLP4 24
ADDRLP4 24
INDIRI4
ADDRLP4 216
INDIRI4
ADDI4
ASGNI4
line 1726
;1726:	break;
ADDRGP4 $529
JUMPV
LABELV $563
line 1728
;1727:      case 'E':
;1728:	flags |= DP_F_UP;
ADDRLP4 20
ADDRLP4 20
INDIRI4
CNSTI4 32
BORI4
ASGNI4
LABELV $564
line 1730
;1729:      case 'e':
;1730:	if (cflags == DP_C_LDOUBLE)
ADDRLP4 12
INDIRI4
CNSTI4 4
NEI4 $565
line 1731
;1731:	  fvalue = va_arg (args, LDOUBLE);
ADDRLP4 220
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 220
INDIRP4
ASGNP4
ADDRLP4 36
ADDRLP4 220
INDIRP4
CNSTI4 -4
ADDP4
INDIRF4
ASGNF4
ADDRGP4 $566
JUMPV
LABELV $565
line 1733
;1732:	else
;1733:	  fvalue = va_arg (args, double);
ADDRLP4 224
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 224
INDIRP4
ASGNP4
ADDRLP4 36
ADDRLP4 224
INDIRP4
CNSTI4 -4
ADDP4
INDIRF4
ASGNF4
LABELV $566
line 1735
;1734:	/* um, floating point? */
;1735:	total += fmtfp (buffer, &currlen, maxlen, fvalue, min, max, flags);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 28
ARGP4
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 36
INDIRF4
ARGF4
ADDRLP4 16
INDIRI4
ARGI4
ADDRLP4 8
INDIRI4
ARGI4
ADDRLP4 20
INDIRI4
ARGI4
ADDRLP4 228
ADDRGP4 fmtfp
CALLI4
ASGNI4
ADDRLP4 24
ADDRLP4 24
INDIRI4
ADDRLP4 228
INDIRI4
ADDI4
ASGNI4
line 1736
;1736:	break;
ADDRGP4 $529
JUMPV
LABELV $567
line 1738
;1737:      case 'G':
;1738:	flags |= DP_F_UP;
ADDRLP4 20
ADDRLP4 20
INDIRI4
CNSTI4 32
BORI4
ASGNI4
LABELV $568
line 1740
;1739:      case 'g':
;1740:	if (cflags == DP_C_LDOUBLE)
ADDRLP4 12
INDIRI4
CNSTI4 4
NEI4 $569
line 1741
;1741:	  fvalue = va_arg (args, LDOUBLE);
ADDRLP4 232
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 232
INDIRP4
ASGNP4
ADDRLP4 36
ADDRLP4 232
INDIRP4
CNSTI4 -4
ADDP4
INDIRF4
ASGNF4
ADDRGP4 $570
JUMPV
LABELV $569
line 1743
;1742:	else
;1743:	  fvalue = va_arg (args, double);
ADDRLP4 236
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 236
INDIRP4
ASGNP4
ADDRLP4 36
ADDRLP4 236
INDIRP4
CNSTI4 -4
ADDP4
INDIRF4
ASGNF4
LABELV $570
line 1745
;1744:	/* um, floating point? */
;1745:	total += fmtfp (buffer, &currlen, maxlen, fvalue, min, max, flags);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 28
ARGP4
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 36
INDIRF4
ARGF4
ADDRLP4 16
INDIRI4
ARGI4
ADDRLP4 8
INDIRI4
ARGI4
ADDRLP4 20
INDIRI4
ARGI4
ADDRLP4 240
ADDRGP4 fmtfp
CALLI4
ASGNI4
ADDRLP4 24
ADDRLP4 24
INDIRI4
ADDRLP4 240
INDIRI4
ADDI4
ASGNI4
line 1746
;1746:	break;
ADDRGP4 $529
JUMPV
LABELV $571
line 1748
;1747:      case 'c':
;1748:	total += dopr_outch (buffer, &currlen, maxlen, va_arg (args, int));
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 28
ARGP4
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 244
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 244
INDIRP4
ASGNP4
ADDRLP4 244
INDIRP4
CNSTI4 -4
ADDP4
INDIRI4
CVII1 4
CVII4 1
ARGI4
ADDRLP4 248
ADDRGP4 dopr_outch
CALLI4
ASGNI4
ADDRLP4 24
ADDRLP4 24
INDIRI4
ADDRLP4 248
INDIRI4
ADDI4
ASGNI4
line 1749
;1749:	break;
ADDRGP4 $529
JUMPV
LABELV $572
line 1751
;1750:      case 's':
;1751:	strvalue = va_arg (args, char *);
ADDRLP4 252
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 252
INDIRP4
ASGNP4
ADDRLP4 40
ADDRLP4 252
INDIRP4
CNSTI4 -4
ADDP4
INDIRP4
ASGNP4
line 1752
;1752:	total += fmtstr (buffer, &currlen, maxlen, strvalue, flags, min, max);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 28
ARGP4
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 40
INDIRP4
ARGP4
ADDRLP4 20
INDIRI4
ARGI4
ADDRLP4 16
INDIRI4
ARGI4
ADDRLP4 8
INDIRI4
ARGI4
ADDRLP4 256
ADDRGP4 fmtstr
CALLI4
ASGNI4
ADDRLP4 24
ADDRLP4 24
INDIRI4
ADDRLP4 256
INDIRI4
ADDI4
ASGNI4
line 1753
;1753:	break;
ADDRGP4 $529
JUMPV
LABELV $573
line 1755
;1754:      case 'p':
;1755:	strvalue = va_arg (args, void *);
ADDRLP4 260
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 260
INDIRP4
ASGNP4
ADDRLP4 40
ADDRLP4 260
INDIRP4
CNSTI4 -4
ADDP4
INDIRP4
ASGNP4
line 1756
;1756:	total += fmtint (buffer, &currlen, maxlen, (long) strvalue, 16, min,
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 28
ARGP4
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 40
INDIRP4
CVPU4 4
CVUI4 4
ARGI4
CNSTI4 16
ARGI4
ADDRLP4 16
INDIRI4
ARGI4
ADDRLP4 8
INDIRI4
ARGI4
ADDRLP4 20
INDIRI4
ARGI4
ADDRLP4 264
ADDRGP4 fmtint
CALLI4
ASGNI4
ADDRLP4 24
ADDRLP4 24
INDIRI4
ADDRLP4 264
INDIRI4
ADDI4
ASGNI4
line 1758
;1757:                         max, flags);
;1758:	break;
ADDRGP4 $529
JUMPV
LABELV $574
line 1760
;1759:      case 'n':
;1760:	if (cflags == DP_C_SHORT) 
ADDRLP4 12
INDIRI4
CNSTI4 1
NEI4 $575
line 1761
;1761:	{
line 1763
;1762:	  short int *num;
;1763:	  num = va_arg (args, short int *);
ADDRLP4 272
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 272
INDIRP4
ASGNP4
ADDRLP4 268
ADDRLP4 272
INDIRP4
CNSTI4 -4
ADDP4
INDIRP4
ASGNP4
line 1764
;1764:	  *num = currlen;
ADDRLP4 268
INDIRP4
ADDRLP4 28
INDIRI4
CVII2 4
ASGNI2
line 1765
;1765:        }
ADDRGP4 $529
JUMPV
LABELV $575
line 1766
;1766:	else if (cflags == DP_C_LONG) 
ADDRLP4 12
INDIRI4
CNSTI4 2
NEI4 $577
line 1767
;1767:	{
line 1769
;1768:	  long int *num;
;1769:	  num = va_arg (args, long int *);
ADDRLP4 272
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 272
INDIRP4
ASGNP4
ADDRLP4 268
ADDRLP4 272
INDIRP4
CNSTI4 -4
ADDP4
INDIRP4
ASGNP4
line 1770
;1770:	  *num = currlen;
ADDRLP4 268
INDIRP4
ADDRLP4 28
INDIRI4
ASGNI4
line 1771
;1771:        } 
ADDRGP4 $529
JUMPV
LABELV $577
line 1772
;1772:	else if (cflags == DP_C_LLONG) 
ADDRLP4 12
INDIRI4
CNSTI4 3
NEI4 $579
line 1773
;1773:	{
line 1775
;1774:	  LLONG *num;
;1775:	  num = va_arg (args, LLONG *);
ADDRLP4 272
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 272
INDIRP4
ASGNP4
ADDRLP4 268
ADDRLP4 272
INDIRP4
CNSTI4 -4
ADDP4
INDIRP4
ASGNP4
line 1776
;1776:	  *num = currlen;
ADDRLP4 268
INDIRP4
ADDRLP4 28
INDIRI4
ASGNI4
line 1777
;1777:        } 
ADDRGP4 $529
JUMPV
LABELV $579
line 1779
;1778:	else 
;1779:	{
line 1781
;1780:	  int *num;
;1781:	  num = va_arg (args, int *);
ADDRLP4 272
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 272
INDIRP4
ASGNP4
ADDRLP4 268
ADDRLP4 272
INDIRP4
CNSTI4 -4
ADDP4
INDIRP4
ASGNP4
line 1782
;1782:	  *num = currlen;
ADDRLP4 268
INDIRP4
ADDRLP4 28
INDIRI4
ASGNI4
line 1783
;1783:        }
line 1784
;1784:	break;
ADDRGP4 $529
JUMPV
LABELV $581
line 1786
;1785:      case '%':
;1786:	total += dopr_outch (buffer, &currlen, maxlen, ch);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 28
ARGP4
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 4
INDIRI1
CVII4 1
ARGI4
ADDRLP4 268
ADDRGP4 dopr_outch
CALLI4
ASGNI4
ADDRLP4 24
ADDRLP4 24
INDIRI4
ADDRLP4 268
INDIRI4
ADDI4
ASGNI4
line 1787
;1787:	break;
ADDRGP4 $529
JUMPV
LABELV $582
line 1790
;1788:      case 'w':
;1789:	/* not supported yet, treat as next char */
;1790:	ch = *format++;
ADDRLP4 272
ADDRFP4 8
INDIRP4
ASGNP4
ADDRFP4 8
ADDRLP4 272
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 4
ADDRLP4 272
INDIRP4
INDIRI1
ASGNI1
line 1791
;1791:	break;
line 1794
;1792:      default:
;1793:	/* Unknown, skip */
;1794:	break;
LABELV $529
line 1796
;1795:      }
;1796:      ch = *format++;
ADDRLP4 128
ADDRFP4 8
INDIRP4
ASGNP4
ADDRFP4 8
ADDRLP4 128
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 4
ADDRLP4 128
INDIRP4
INDIRI1
ASGNI1
line 1797
;1797:      state = DP_S_DEFAULT;
ADDRLP4 0
CNSTI4 0
ASGNI4
line 1798
;1798:      flags = cflags = min = 0;
ADDRLP4 132
CNSTI4 0
ASGNI4
ADDRLP4 16
ADDRLP4 132
INDIRI4
ASGNI4
ADDRLP4 12
ADDRLP4 132
INDIRI4
ASGNI4
ADDRLP4 20
ADDRLP4 132
INDIRI4
ASGNI4
line 1799
;1799:      max = -1;
ADDRLP4 8
CNSTI4 -1
ASGNI4
line 1800
;1800:      break;
line 1802
;1801:    case DP_S_DONE:
;1802:      break;
line 1805
;1803:    default:
;1804:      /* hmm? */
;1805:      break; /* some picky compilers need this */
LABELV $482
line 1807
;1806:    }
;1807:  }
LABELV $477
line 1547
ADDRLP4 0
INDIRI4
CNSTI4 8
NEI4 $476
line 1808
;1808:  if (buffer != NULL)
ADDRFP4 0
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $590
line 1809
;1809:  {
line 1810
;1810:    if (currlen < maxlen - 1) 
ADDRLP4 28
INDIRI4
ADDRFP4 4
INDIRI4
CNSTI4 1
SUBI4
GEI4 $592
line 1811
;1811:      buffer[currlen] = '\0';
ADDRLP4 28
INDIRI4
ADDRFP4 0
INDIRP4
ADDP4
CNSTI1 0
ASGNI1
ADDRGP4 $593
JUMPV
LABELV $592
line 1813
;1812:    else 
;1813:      buffer[maxlen - 1] = '\0';
ADDRFP4 4
INDIRI4
CNSTI4 1
SUBI4
ADDRFP4 0
INDIRP4
ADDP4
CNSTI1 0
ASGNI1
LABELV $593
line 1814
;1814:  }
LABELV $590
line 1815
;1815:  return total;
ADDRLP4 24
INDIRI4
RETI4
LABELV $475
endproc dopr 276 32
proc fmtstr 32 16
line 1820
;1816:}
;1817:
;1818:static int fmtstr (char *buffer, size_t *currlen, size_t maxlen,
;1819:                   char *value, int flags, int min, int max)
;1820:{
line 1822
;1821:  int padlen, strln;     /* amount to pad */
;1822:  int cnt = 0;
ADDRLP4 12
CNSTI4 0
ASGNI4
line 1823
;1823:  int total = 0;
ADDRLP4 4
CNSTI4 0
ASGNI4
line 1825
;1824:  
;1825:  if (value == 0)
ADDRFP4 12
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $595
line 1826
;1826:  {
line 1827
;1827:    value = "<NULL>";
ADDRFP4 12
ADDRGP4 $597
ASGNP4
line 1828
;1828:  }
LABELV $595
line 1830
;1829:
;1830:  for (strln = 0; value[strln]; ++strln); /* strlen */
ADDRLP4 8
CNSTI4 0
ASGNI4
ADDRGP4 $601
JUMPV
LABELV $598
LABELV $599
ADDRLP4 8
ADDRLP4 8
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
LABELV $601
ADDRLP4 8
INDIRI4
ADDRFP4 12
INDIRP4
ADDP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $598
line 1831
;1831:  if (max >= 0 && max < strln)
ADDRLP4 16
ADDRFP4 24
INDIRI4
ASGNI4
ADDRLP4 16
INDIRI4
CNSTI4 0
LTI4 $602
ADDRLP4 16
INDIRI4
ADDRLP4 8
INDIRI4
GEI4 $602
line 1832
;1832:    strln = max;
ADDRLP4 8
ADDRFP4 24
INDIRI4
ASGNI4
LABELV $602
line 1833
;1833:  padlen = min - strln;
ADDRLP4 0
ADDRFP4 20
INDIRI4
ADDRLP4 8
INDIRI4
SUBI4
ASGNI4
line 1834
;1834:  if (padlen < 0) 
ADDRLP4 0
INDIRI4
CNSTI4 0
GEI4 $604
line 1835
;1835:    padlen = 0;
ADDRLP4 0
CNSTI4 0
ASGNI4
LABELV $604
line 1836
;1836:  if (flags & DP_F_MINUS) 
ADDRFP4 16
INDIRI4
CNSTI4 1
BANDI4
CNSTI4 0
EQI4 $609
line 1837
;1837:    padlen = -padlen; /* Left Justify */
ADDRLP4 0
ADDRLP4 0
INDIRI4
NEGI4
ASGNI4
ADDRGP4 $609
JUMPV
LABELV $608
line 1840
;1838:
;1839:  while (padlen > 0)
;1840:  {
line 1841
;1841:    total += dopr_outch (buffer, currlen, maxlen, ' ');
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRFP4 8
INDIRI4
ARGI4
CNSTI4 32
ARGI4
ADDRLP4 20
ADDRGP4 dopr_outch
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 4
INDIRI4
ADDRLP4 20
INDIRI4
ADDI4
ASGNI4
line 1842
;1842:    --padlen;
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
SUBI4
ASGNI4
line 1843
;1843:  }
LABELV $609
line 1839
ADDRLP4 0
INDIRI4
CNSTI4 0
GTI4 $608
ADDRGP4 $612
JUMPV
LABELV $611
line 1845
;1844:  while (*value && ((max < 0) || (cnt < max)))
;1845:  {
line 1846
;1846:    total += dopr_outch (buffer, currlen, maxlen, *value++);
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRFP4 8
INDIRI4
ARGI4
ADDRLP4 20
ADDRFP4 12
INDIRP4
ASGNP4
ADDRFP4 12
ADDRLP4 20
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 20
INDIRP4
INDIRI1
CVII4 1
ARGI4
ADDRLP4 24
ADDRGP4 dopr_outch
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 4
INDIRI4
ADDRLP4 24
INDIRI4
ADDI4
ASGNI4
line 1847
;1847:    ++cnt;
ADDRLP4 12
ADDRLP4 12
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
line 1848
;1848:  }
LABELV $612
line 1844
ADDRLP4 20
CNSTI4 0
ASGNI4
ADDRFP4 12
INDIRP4
INDIRI1
CVII4 1
ADDRLP4 20
INDIRI4
EQI4 $614
ADDRLP4 24
ADDRFP4 24
INDIRI4
ASGNI4
ADDRLP4 24
INDIRI4
ADDRLP4 20
INDIRI4
LTI4 $611
ADDRLP4 12
INDIRI4
ADDRLP4 24
INDIRI4
LTI4 $611
LABELV $614
ADDRGP4 $616
JUMPV
LABELV $615
line 1850
;1849:  while (padlen < 0)
;1850:  {
line 1851
;1851:    total += dopr_outch (buffer, currlen, maxlen, ' ');
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRFP4 8
INDIRI4
ARGI4
CNSTI4 32
ARGI4
ADDRLP4 28
ADDRGP4 dopr_outch
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 4
INDIRI4
ADDRLP4 28
INDIRI4
ADDI4
ASGNI4
line 1852
;1852:    ++padlen;
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
line 1853
;1853:  }
LABELV $616
line 1849
ADDRLP4 0
INDIRI4
CNSTI4 0
LTI4 $615
line 1854
;1854:  return total;
ADDRLP4 4
INDIRI4
RETI4
LABELV $594
endproc fmtstr 32 16
proc fmtint 76 16
line 1861
;1855:}
;1856:
;1857:/* Have to handle DP_F_NUM (ie 0x and 0 alternates) */
;1858:
;1859:static int fmtint (char *buffer, size_t *currlen, size_t maxlen,
;1860:		   LLONG value, int base, int min, int max, int flags)
;1861:{
line 1862
;1862:  int signvalue = 0;
ADDRLP4 48
CNSTI4 0
ASGNI4
line 1865
;1863:  unsigned LLONG uvalue;
;1864:  char convert[24];
;1865:  int place = 0;
ADDRLP4 0
CNSTI4 0
ASGNI4
line 1866
;1866:  int spadlen = 0; /* amount to space pad */
ADDRLP4 4
CNSTI4 0
ASGNI4
line 1867
;1867:  int zpadlen = 0; /* amount to zero pad */
ADDRLP4 40
CNSTI4 0
ASGNI4
line 1869
;1868:  const char *digits;
;1869:  int total = 0;
ADDRLP4 12
CNSTI4 0
ASGNI4
line 1871
;1870:  
;1871:  if (max < 0)
ADDRFP4 24
INDIRI4
CNSTI4 0
GEI4 $619
line 1872
;1872:    max = 0;
ADDRFP4 24
CNSTI4 0
ASGNI4
LABELV $619
line 1874
;1873:
;1874:  uvalue = value;
ADDRLP4 8
ADDRFP4 12
INDIRI4
CVIU4 4
ASGNU4
line 1876
;1875:
;1876:  if(!(flags & DP_F_UNSIGNED))
ADDRFP4 28
INDIRI4
CNSTI4 64
BANDI4
CNSTI4 0
NEI4 $621
line 1877
;1877:  {
line 1878
;1878:    if( value < 0 ) {
ADDRFP4 12
INDIRI4
CNSTI4 0
GEI4 $623
line 1879
;1879:      signvalue = '-';
ADDRLP4 48
CNSTI4 45
ASGNI4
line 1880
;1880:      uvalue = -value;
ADDRLP4 8
ADDRFP4 12
INDIRI4
NEGI4
CVIU4 4
ASGNU4
line 1881
;1881:    }
ADDRGP4 $624
JUMPV
LABELV $623
line 1883
;1882:    else
;1883:      if (flags & DP_F_PLUS)  /* Do a sign (+/i) */
ADDRFP4 28
INDIRI4
CNSTI4 2
BANDI4
CNSTI4 0
EQI4 $625
line 1884
;1884:	signvalue = '+';
ADDRLP4 48
CNSTI4 43
ASGNI4
ADDRGP4 $626
JUMPV
LABELV $625
line 1886
;1885:    else
;1886:      if (flags & DP_F_SPACE)
ADDRFP4 28
INDIRI4
CNSTI4 4
BANDI4
CNSTI4 0
EQI4 $627
line 1887
;1887:	signvalue = ' ';
ADDRLP4 48
CNSTI4 32
ASGNI4
LABELV $627
LABELV $626
LABELV $624
line 1888
;1888:  }
LABELV $621
line 1890
;1889:  
;1890:  if (flags & DP_F_UP)
ADDRFP4 28
INDIRI4
CNSTI4 32
BANDI4
CNSTI4 0
EQI4 $629
line 1892
;1891:    /* Should characters be upper case? */
;1892:    digits = "0123456789ABCDEF";
ADDRLP4 44
ADDRGP4 $631
ASGNP4
ADDRGP4 $630
JUMPV
LABELV $629
line 1894
;1893:  else
;1894:    digits = "0123456789abcdef";
ADDRLP4 44
ADDRGP4 $632
ASGNP4
LABELV $630
LABELV $633
line 1896
;1895:
;1896:  do {
line 1897
;1897:    convert[place++] = digits[uvalue % (unsigned)base];
ADDRLP4 52
ADDRLP4 0
INDIRI4
ASGNI4
ADDRLP4 0
ADDRLP4 52
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
ADDRLP4 52
INDIRI4
ADDRLP4 16
ADDP4
ADDRLP4 8
INDIRU4
ADDRFP4 16
INDIRI4
CVIU4 4
MODU4
ADDRLP4 44
INDIRP4
ADDP4
INDIRI1
ASGNI1
line 1898
;1898:    uvalue = (uvalue / (unsigned)base );
ADDRLP4 8
ADDRLP4 8
INDIRU4
ADDRFP4 16
INDIRI4
CVIU4 4
DIVU4
ASGNU4
line 1899
;1899:  } while(uvalue && (place < sizeof (convert)));
LABELV $634
ADDRLP4 8
INDIRU4
CNSTU4 0
EQU4 $636
ADDRLP4 0
INDIRI4
CVIU4 4
CNSTU4 24
LTU4 $633
LABELV $636
line 1900
;1900:  if (place == sizeof (convert)) place--;
ADDRLP4 0
INDIRI4
CVIU4 4
CNSTU4 24
NEU4 $637
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
SUBI4
ASGNI4
LABELV $637
line 1901
;1901:  convert[place] = 0;
ADDRLP4 0
INDIRI4
ADDRLP4 16
ADDP4
CNSTI1 0
ASGNI1
line 1903
;1902:
;1903:  zpadlen = max - place;
ADDRLP4 40
ADDRFP4 24
INDIRI4
ADDRLP4 0
INDIRI4
SUBI4
ASGNI4
line 1904
;1904:  spadlen = min - MAX (max, place) - (signvalue ? 1 : 0);
ADDRFP4 24
INDIRI4
ADDRLP4 0
INDIRI4
LTI4 $641
ADDRLP4 52
ADDRFP4 24
INDIRI4
ASGNI4
ADDRGP4 $642
JUMPV
LABELV $641
ADDRLP4 52
ADDRLP4 0
INDIRI4
ASGNI4
LABELV $642
ADDRLP4 48
INDIRI4
CNSTI4 0
EQI4 $643
ADDRLP4 56
CNSTI4 1
ASGNI4
ADDRGP4 $644
JUMPV
LABELV $643
ADDRLP4 56
CNSTI4 0
ASGNI4
LABELV $644
ADDRLP4 4
ADDRFP4 20
INDIRI4
ADDRLP4 52
INDIRI4
SUBI4
ADDRLP4 56
INDIRI4
SUBI4
ASGNI4
line 1905
;1905:  if (zpadlen < 0) zpadlen = 0;
ADDRLP4 40
INDIRI4
CNSTI4 0
GEI4 $645
ADDRLP4 40
CNSTI4 0
ASGNI4
LABELV $645
line 1906
;1906:  if (spadlen < 0) spadlen = 0;
ADDRLP4 4
INDIRI4
CNSTI4 0
GEI4 $647
ADDRLP4 4
CNSTI4 0
ASGNI4
LABELV $647
line 1907
;1907:  if (flags & DP_F_ZERO)
ADDRFP4 28
INDIRI4
CNSTI4 16
BANDI4
CNSTI4 0
EQI4 $649
line 1908
;1908:  {
line 1909
;1909:    zpadlen = MAX(zpadlen, spadlen);
ADDRLP4 40
INDIRI4
ADDRLP4 4
INDIRI4
LTI4 $652
ADDRLP4 60
ADDRLP4 40
INDIRI4
ASGNI4
ADDRGP4 $653
JUMPV
LABELV $652
ADDRLP4 60
ADDRLP4 4
INDIRI4
ASGNI4
LABELV $653
ADDRLP4 40
ADDRLP4 60
INDIRI4
ASGNI4
line 1910
;1910:    spadlen = 0;
ADDRLP4 4
CNSTI4 0
ASGNI4
line 1911
;1911:  }
LABELV $649
line 1912
;1912:  if (flags & DP_F_MINUS) 
ADDRFP4 28
INDIRI4
CNSTI4 1
BANDI4
CNSTI4 0
EQI4 $657
line 1913
;1913:    spadlen = -spadlen; /* Left Justifty */
ADDRLP4 4
ADDRLP4 4
INDIRI4
NEGI4
ASGNI4
ADDRGP4 $657
JUMPV
LABELV $656
line 1922
;1914:
;1915:#ifdef DEBUG_SNPRINTF
;1916:  dprint (1, (debugfile, "zpad: %d, spad: %d, min: %d, max: %d, place: %d\n",
;1917:      zpadlen, spadlen, min, max, place));
;1918:#endif
;1919:
;1920:  /* Spaces */
;1921:  while (spadlen > 0) 
;1922:  {
line 1923
;1923:    total += dopr_outch (buffer, currlen, maxlen, ' ');
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRFP4 8
INDIRI4
ARGI4
CNSTI4 32
ARGI4
ADDRLP4 60
ADDRGP4 dopr_outch
CALLI4
ASGNI4
ADDRLP4 12
ADDRLP4 12
INDIRI4
ADDRLP4 60
INDIRI4
ADDI4
ASGNI4
line 1924
;1924:    --spadlen;
ADDRLP4 4
ADDRLP4 4
INDIRI4
CNSTI4 1
SUBI4
ASGNI4
line 1925
;1925:  }
LABELV $657
line 1921
ADDRLP4 4
INDIRI4
CNSTI4 0
GTI4 $656
line 1928
;1926:
;1927:  /* Sign */
;1928:  if (signvalue) 
ADDRLP4 48
INDIRI4
CNSTI4 0
EQI4 $659
line 1929
;1929:    total += dopr_outch (buffer, currlen, maxlen, signvalue);
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRFP4 8
INDIRI4
ARGI4
ADDRLP4 48
INDIRI4
CVII1 4
CVII4 1
ARGI4
ADDRLP4 60
ADDRGP4 dopr_outch
CALLI4
ASGNI4
ADDRLP4 12
ADDRLP4 12
INDIRI4
ADDRLP4 60
INDIRI4
ADDI4
ASGNI4
LABELV $659
line 1932
;1930:
;1931:  /* Zeros */
;1932:  if (zpadlen > 0) 
ADDRLP4 40
INDIRI4
CNSTI4 0
LEI4 $667
line 1933
;1933:  {
ADDRGP4 $664
JUMPV
LABELV $663
line 1935
;1934:    while (zpadlen > 0)
;1935:    {
line 1936
;1936:      total += dopr_outch (buffer, currlen, maxlen, '0');
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRFP4 8
INDIRI4
ARGI4
CNSTI4 48
ARGI4
ADDRLP4 64
ADDRGP4 dopr_outch
CALLI4
ASGNI4
ADDRLP4 12
ADDRLP4 12
INDIRI4
ADDRLP4 64
INDIRI4
ADDI4
ASGNI4
line 1937
;1937:      --zpadlen;
ADDRLP4 40
ADDRLP4 40
INDIRI4
CNSTI4 1
SUBI4
ASGNI4
line 1938
;1938:    }
LABELV $664
line 1934
ADDRLP4 40
INDIRI4
CNSTI4 0
GTI4 $663
line 1939
;1939:  }
ADDRGP4 $667
JUMPV
LABELV $666
line 1943
;1940:
;1941:  /* Digits */
;1942:  while (place > 0) 
;1943:    total += dopr_outch (buffer, currlen, maxlen, convert[--place]);
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRFP4 8
INDIRI4
ARGI4
ADDRLP4 64
ADDRLP4 0
INDIRI4
CNSTI4 1
SUBI4
ASGNI4
ADDRLP4 0
ADDRLP4 64
INDIRI4
ASGNI4
ADDRLP4 64
INDIRI4
ADDRLP4 16
ADDP4
INDIRI1
CVII4 1
ARGI4
ADDRLP4 68
ADDRGP4 dopr_outch
CALLI4
ASGNI4
ADDRLP4 12
ADDRLP4 12
INDIRI4
ADDRLP4 68
INDIRI4
ADDI4
ASGNI4
LABELV $667
line 1942
ADDRLP4 0
INDIRI4
CNSTI4 0
GTI4 $666
ADDRGP4 $670
JUMPV
LABELV $669
line 1946
;1944:  
;1945:  /* Left Justified spaces */
;1946:  while (spadlen < 0) {
line 1947
;1947:    total += dopr_outch (buffer, currlen, maxlen, ' ');
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRFP4 8
INDIRI4
ARGI4
CNSTI4 32
ARGI4
ADDRLP4 72
ADDRGP4 dopr_outch
CALLI4
ASGNI4
ADDRLP4 12
ADDRLP4 12
INDIRI4
ADDRLP4 72
INDIRI4
ADDI4
ASGNI4
line 1948
;1948:    ++spadlen;
ADDRLP4 4
ADDRLP4 4
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
line 1949
;1949:  }
LABELV $670
line 1946
ADDRLP4 4
INDIRI4
CNSTI4 0
LTI4 $669
line 1951
;1950:
;1951:  return total;
ADDRLP4 12
INDIRI4
RETI4
LABELV $618
endproc fmtint 76 16
proc abs_val 4 0
line 1955
;1952:}
;1953:
;1954:static LDOUBLE abs_val (LDOUBLE value)
;1955:{
line 1956
;1956:  LDOUBLE result = value;
ADDRLP4 0
ADDRFP4 0
INDIRF4
ASGNF4
line 1958
;1957:
;1958:  if (value < 0)
ADDRFP4 0
INDIRF4
CNSTF4 0
GEF4 $673
line 1959
;1959:    result = -value;
ADDRLP4 0
ADDRFP4 0
INDIRF4
NEGF4
ASGNF4
LABELV $673
line 1961
;1960:
;1961:  return result;
ADDRLP4 0
INDIRF4
RETF4
LABELV $672
endproc abs_val 4 0
proc pow10 4 0
line 1965
;1962:}
;1963:
;1964:static LDOUBLE pow10 (int exp)
;1965:{
line 1966
;1966:  LDOUBLE result = 1;
ADDRLP4 0
CNSTF4 1065353216
ASGNF4
ADDRGP4 $677
JUMPV
LABELV $676
line 1969
;1967:
;1968:  while (exp)
;1969:  {
line 1970
;1970:    result *= 10;
ADDRLP4 0
CNSTF4 1092616192
ADDRLP4 0
INDIRF4
MULF4
ASGNF4
line 1971
;1971:    exp--;
ADDRFP4 0
ADDRFP4 0
INDIRI4
CNSTI4 1
SUBI4
ASGNI4
line 1972
;1972:  }
LABELV $677
line 1968
ADDRFP4 0
INDIRI4
CNSTI4 0
NEI4 $676
line 1974
;1973:  
;1974:  return result;
ADDRLP4 0
INDIRF4
RETF4
LABELV $675
endproc pow10 4 0
proc round 4 0
line 1978
;1975:}
;1976:
;1977:static long round (LDOUBLE value)
;1978:{
line 1981
;1979:  long intpart;
;1980:
;1981:  intpart = value;
ADDRLP4 0
ADDRFP4 0
INDIRF4
CVFI4 4
ASGNI4
line 1982
;1982:  value = value - intpart;
ADDRFP4 0
ADDRFP4 0
INDIRF4
ADDRLP4 0
INDIRI4
CVIF4 4
SUBF4
ASGNF4
line 1983
;1983:  if (value >= 0.5)
ADDRFP4 0
INDIRF4
CNSTF4 1056964608
LTF4 $680
line 1984
;1984:    intpart++;
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
LABELV $680
line 1986
;1985:
;1986:  return intpart;
ADDRLP4 0
INDIRI4
RETI4
LABELV $679
endproc round 4 0
proc fmtfp 136 16
line 1991
;1987:}
;1988:
;1989:static int fmtfp (char *buffer, size_t *currlen, size_t maxlen,
;1990:		  LDOUBLE fvalue, int min, int max, int flags)
;1991:{
line 1992
;1992:  int signvalue = 0;
ADDRLP4 72
CNSTI4 0
ASGNI4
line 1996
;1993:  LDOUBLE ufvalue;
;1994:  char iconvert[20];
;1995:  char fconvert[20];
;1996:  int iplace = 0;
ADDRLP4 8
CNSTI4 0
ASGNI4
line 1997
;1997:  int fplace = 0;
ADDRLP4 20
CNSTI4 0
ASGNI4
line 1998
;1998:  int padlen = 0; /* amount to pad */
ADDRLP4 0
CNSTI4 0
ASGNI4
line 1999
;1999:  int zpadlen = 0; 
ADDRLP4 68
CNSTI4 0
ASGNI4
line 2000
;2000:  int caps = 0;
ADDRLP4 44
CNSTI4 0
ASGNI4
line 2001
;2001:  int total = 0;
ADDRLP4 4
CNSTI4 0
ASGNI4
line 2009
;2002:  long intpart;
;2003:  long fracpart;
;2004:  
;2005:  /* 
;2006:   * AIX manpage says the default is 0, but Solaris says the default
;2007:   * is 6, and sprintf on AIX defaults to 6
;2008:   */
;2009:  if (max < 0)
ADDRFP4 20
INDIRI4
CNSTI4 0
GEI4 $683
line 2010
;2010:    max = 6;
ADDRFP4 20
CNSTI4 6
ASGNI4
LABELV $683
line 2012
;2011:
;2012:  ufvalue = abs_val (fvalue);
ADDRFP4 12
INDIRF4
ARGF4
ADDRLP4 80
ADDRGP4 abs_val
CALLF4
ASGNF4
ADDRLP4 76
ADDRLP4 80
INDIRF4
ASGNF4
line 2014
;2013:
;2014:  if (fvalue < 0)
ADDRFP4 12
INDIRF4
CNSTF4 0
GEF4 $685
line 2015
;2015:    signvalue = '-';
ADDRLP4 72
CNSTI4 45
ASGNI4
ADDRGP4 $686
JUMPV
LABELV $685
line 2017
;2016:  else
;2017:    if (flags & DP_F_PLUS)  /* Do a sign (+/i) */
ADDRFP4 24
INDIRI4
CNSTI4 2
BANDI4
CNSTI4 0
EQI4 $687
line 2018
;2018:      signvalue = '+';
ADDRLP4 72
CNSTI4 43
ASGNI4
ADDRGP4 $688
JUMPV
LABELV $687
line 2020
;2019:    else
;2020:      if (flags & DP_F_SPACE)
ADDRFP4 24
INDIRI4
CNSTI4 4
BANDI4
CNSTI4 0
EQI4 $689
line 2021
;2021:	signvalue = ' ';
ADDRLP4 72
CNSTI4 32
ASGNI4
LABELV $689
LABELV $688
LABELV $686
line 2027
;2022:
;2023:#if 0
;2024:  if (flags & DP_F_UP) caps = 1; /* Should characters be upper case? */
;2025:#endif
;2026:
;2027:  intpart = ufvalue;
ADDRLP4 12
ADDRLP4 76
INDIRF4
CVFI4 4
ASGNI4
line 2033
;2028:
;2029:  /* 
;2030:   * Sorry, we only support 9 digits past the decimal because of our 
;2031:   * conversion method
;2032:   */
;2033:  if (max > 9)
ADDRFP4 20
INDIRI4
CNSTI4 9
LEI4 $691
line 2034
;2034:    max = 9;
ADDRFP4 20
CNSTI4 9
ASGNI4
LABELV $691
line 2039
;2035:
;2036:  /* We "cheat" by converting the fractional part to integer by
;2037:   * multiplying by a factor of 10
;2038:   */
;2039:  fracpart = round ((pow10 (max)) * (ufvalue - intpart));
ADDRFP4 20
INDIRI4
ARGI4
ADDRLP4 84
ADDRGP4 pow10
CALLF4
ASGNF4
ADDRLP4 84
INDIRF4
ADDRLP4 76
INDIRF4
ADDRLP4 12
INDIRI4
CVIF4 4
SUBF4
MULF4
ARGF4
ADDRLP4 88
ADDRGP4 round
CALLI4
ASGNI4
ADDRLP4 16
ADDRLP4 88
INDIRI4
ASGNI4
line 2041
;2040:
;2041:  if (fracpart >= pow10 (max))
ADDRFP4 20
INDIRI4
ARGI4
ADDRLP4 92
ADDRGP4 pow10
CALLF4
ASGNF4
ADDRLP4 16
INDIRI4
CVIF4 4
ADDRLP4 92
INDIRF4
LTF4 $693
line 2042
;2042:  {
line 2043
;2043:    intpart++;
ADDRLP4 12
ADDRLP4 12
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
line 2044
;2044:    fracpart -= pow10 (max);
ADDRFP4 20
INDIRI4
ARGI4
ADDRLP4 96
ADDRGP4 pow10
CALLF4
ASGNF4
ADDRLP4 16
ADDRLP4 16
INDIRI4
CVIF4 4
ADDRLP4 96
INDIRF4
SUBF4
CVFI4 4
ASGNI4
line 2045
;2045:  }
LABELV $693
LABELV $695
line 2052
;2046:
;2047:#ifdef DEBUG_SNPRINTF
;2048:  dprint (1, (debugfile, "fmtfp: %f =? %d.%d\n", fvalue, intpart, fracpart));
;2049:#endif
;2050:
;2051:  /* Convert integer part */
;2052:  do {
line 2053
;2053:    iconvert[iplace++] =
ADDRLP4 100
ADDRLP4 8
INDIRI4
ASGNI4
ADDRLP4 8
ADDRLP4 100
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
ADDRLP4 44
INDIRI4
CNSTI4 0
EQI4 $699
ADDRLP4 96
ADDRGP4 $631
ASGNP4
ADDRGP4 $700
JUMPV
LABELV $699
ADDRLP4 96
ADDRGP4 $632
ASGNP4
LABELV $700
ADDRLP4 100
INDIRI4
ADDRLP4 24
ADDP4
ADDRLP4 12
INDIRI4
CNSTI4 10
MODI4
ADDRLP4 96
INDIRP4
ADDP4
INDIRI1
ASGNI1
line 2055
;2054:      (caps? "0123456789ABCDEF":"0123456789abcdef")[intpart % 10];
;2055:    intpart = (intpart / 10);
ADDRLP4 12
ADDRLP4 12
INDIRI4
CNSTI4 10
DIVI4
ASGNI4
line 2056
;2056:  } while(intpart && (iplace < 20));
LABELV $696
ADDRLP4 12
INDIRI4
CNSTI4 0
EQI4 $701
ADDRLP4 8
INDIRI4
CNSTI4 20
LTI4 $695
LABELV $701
line 2057
;2057:  if (iplace == 20) iplace--;
ADDRLP4 8
INDIRI4
CNSTI4 20
NEI4 $702
ADDRLP4 8
ADDRLP4 8
INDIRI4
CNSTI4 1
SUBI4
ASGNI4
LABELV $702
line 2058
;2058:  iconvert[iplace] = 0;
ADDRLP4 8
INDIRI4
ADDRLP4 24
ADDP4
CNSTI1 0
ASGNI1
LABELV $704
line 2061
;2059:
;2060:  /* Convert fractional part */
;2061:  do {
line 2062
;2062:    fconvert[fplace++] =
ADDRLP4 100
ADDRLP4 20
INDIRI4
ASGNI4
ADDRLP4 20
ADDRLP4 100
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
ADDRLP4 44
INDIRI4
CNSTI4 0
EQI4 $708
ADDRLP4 96
ADDRGP4 $631
ASGNP4
ADDRGP4 $709
JUMPV
LABELV $708
ADDRLP4 96
ADDRGP4 $632
ASGNP4
LABELV $709
ADDRLP4 100
INDIRI4
ADDRLP4 48
ADDP4
ADDRLP4 16
INDIRI4
CNSTI4 10
MODI4
ADDRLP4 96
INDIRP4
ADDP4
INDIRI1
ASGNI1
line 2064
;2063:      (caps? "0123456789ABCDEF":"0123456789abcdef")[fracpart % 10];
;2064:    fracpart = (fracpart / 10);
ADDRLP4 16
ADDRLP4 16
INDIRI4
CNSTI4 10
DIVI4
ASGNI4
line 2065
;2065:  } while(fracpart && (fplace < 20));
LABELV $705
ADDRLP4 16
INDIRI4
CNSTI4 0
EQI4 $710
ADDRLP4 20
INDIRI4
CNSTI4 20
LTI4 $704
LABELV $710
line 2066
;2066:  if (fplace == 20) fplace--;
ADDRLP4 20
INDIRI4
CNSTI4 20
NEI4 $711
ADDRLP4 20
ADDRLP4 20
INDIRI4
CNSTI4 1
SUBI4
ASGNI4
LABELV $711
line 2067
;2067:  fconvert[fplace] = 0;
ADDRLP4 20
INDIRI4
ADDRLP4 48
ADDP4
CNSTI1 0
ASGNI1
line 2070
;2068:
;2069:  /* -1 for decimal point, another -1 if we are printing a sign */
;2070:  padlen = min - iplace - max - 1 - ((signvalue) ? 1 : 0); 
ADDRLP4 72
INDIRI4
CNSTI4 0
EQI4 $714
ADDRLP4 96
CNSTI4 1
ASGNI4
ADDRGP4 $715
JUMPV
LABELV $714
ADDRLP4 96
CNSTI4 0
ASGNI4
LABELV $715
ADDRLP4 0
ADDRFP4 16
INDIRI4
ADDRLP4 8
INDIRI4
SUBI4
ADDRFP4 20
INDIRI4
SUBI4
CNSTI4 1
SUBI4
ADDRLP4 96
INDIRI4
SUBI4
ASGNI4
line 2071
;2071:  zpadlen = max - fplace;
ADDRLP4 68
ADDRFP4 20
INDIRI4
ADDRLP4 20
INDIRI4
SUBI4
ASGNI4
line 2072
;2072:  if (zpadlen < 0)
ADDRLP4 68
INDIRI4
CNSTI4 0
GEI4 $716
line 2073
;2073:    zpadlen = 0;
ADDRLP4 68
CNSTI4 0
ASGNI4
LABELV $716
line 2074
;2074:  if (padlen < 0) 
ADDRLP4 0
INDIRI4
CNSTI4 0
GEI4 $718
line 2075
;2075:    padlen = 0;
ADDRLP4 0
CNSTI4 0
ASGNI4
LABELV $718
line 2076
;2076:  if (flags & DP_F_MINUS) 
ADDRFP4 24
INDIRI4
CNSTI4 1
BANDI4
CNSTI4 0
EQI4 $720
line 2077
;2077:    padlen = -padlen; /* Left Justifty */
ADDRLP4 0
ADDRLP4 0
INDIRI4
NEGI4
ASGNI4
LABELV $720
line 2079
;2078:
;2079:  if ((flags & DP_F_ZERO) && (padlen > 0)) 
ADDRLP4 100
CNSTI4 0
ASGNI4
ADDRFP4 24
INDIRI4
CNSTI4 16
BANDI4
ADDRLP4 100
INDIRI4
EQI4 $730
ADDRLP4 0
INDIRI4
ADDRLP4 100
INDIRI4
LEI4 $730
line 2080
;2080:  {
line 2081
;2081:    if (signvalue) 
ADDRLP4 72
INDIRI4
CNSTI4 0
EQI4 $727
line 2082
;2082:    {
line 2083
;2083:      total += dopr_outch (buffer, currlen, maxlen, signvalue);
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRFP4 8
INDIRI4
ARGI4
ADDRLP4 72
INDIRI4
CVII1 4
CVII4 1
ARGI4
ADDRLP4 104
ADDRGP4 dopr_outch
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 4
INDIRI4
ADDRLP4 104
INDIRI4
ADDI4
ASGNI4
line 2084
;2084:      --padlen;
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
SUBI4
ASGNI4
line 2085
;2085:      signvalue = 0;
ADDRLP4 72
CNSTI4 0
ASGNI4
line 2086
;2086:    }
ADDRGP4 $727
JUMPV
LABELV $726
line 2088
;2087:    while (padlen > 0)
;2088:    {
line 2089
;2089:      total += dopr_outch (buffer, currlen, maxlen, '0');
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRFP4 8
INDIRI4
ARGI4
CNSTI4 48
ARGI4
ADDRLP4 104
ADDRGP4 dopr_outch
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 4
INDIRI4
ADDRLP4 104
INDIRI4
ADDI4
ASGNI4
line 2090
;2090:      --padlen;
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
SUBI4
ASGNI4
line 2091
;2091:    }
LABELV $727
line 2087
ADDRLP4 0
INDIRI4
CNSTI4 0
GTI4 $726
line 2092
;2092:  }
ADDRGP4 $730
JUMPV
LABELV $729
line 2094
;2093:  while (padlen > 0)
;2094:  {
line 2095
;2095:    total += dopr_outch (buffer, currlen, maxlen, ' ');
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRFP4 8
INDIRI4
ARGI4
CNSTI4 32
ARGI4
ADDRLP4 104
ADDRGP4 dopr_outch
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 4
INDIRI4
ADDRLP4 104
INDIRI4
ADDI4
ASGNI4
line 2096
;2096:    --padlen;
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
SUBI4
ASGNI4
line 2097
;2097:  }
LABELV $730
line 2093
ADDRLP4 0
INDIRI4
CNSTI4 0
GTI4 $729
line 2098
;2098:  if (signvalue) 
ADDRLP4 72
INDIRI4
CNSTI4 0
EQI4 $735
line 2099
;2099:    total += dopr_outch (buffer, currlen, maxlen, signvalue);
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRFP4 8
INDIRI4
ARGI4
ADDRLP4 72
INDIRI4
CVII1 4
CVII4 1
ARGI4
ADDRLP4 104
ADDRGP4 dopr_outch
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 4
INDIRI4
ADDRLP4 104
INDIRI4
ADDI4
ASGNI4
ADDRGP4 $735
JUMPV
LABELV $734
line 2102
;2100:
;2101:  while (iplace > 0) 
;2102:    total += dopr_outch (buffer, currlen, maxlen, iconvert[--iplace]);
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRFP4 8
INDIRI4
ARGI4
ADDRLP4 108
ADDRLP4 8
INDIRI4
CNSTI4 1
SUBI4
ASGNI4
ADDRLP4 8
ADDRLP4 108
INDIRI4
ASGNI4
ADDRLP4 108
INDIRI4
ADDRLP4 24
ADDP4
INDIRI1
CVII4 1
ARGI4
ADDRLP4 112
ADDRGP4 dopr_outch
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 4
INDIRI4
ADDRLP4 112
INDIRI4
ADDI4
ASGNI4
LABELV $735
line 2101
ADDRLP4 8
INDIRI4
CNSTI4 0
GTI4 $734
line 2108
;2103:
;2104:  /*
;2105:   * Decimal point.  This should probably use locale to find the correct
;2106:   * char to print out.
;2107:   */
;2108:  if (max > 0)
ADDRFP4 20
INDIRI4
CNSTI4 0
LEI4 $746
line 2109
;2109:  {
line 2110
;2110:    total += dopr_outch (buffer, currlen, maxlen, '.');
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRFP4 8
INDIRI4
ARGI4
CNSTI4 46
ARGI4
ADDRLP4 116
ADDRGP4 dopr_outch
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 4
INDIRI4
ADDRLP4 116
INDIRI4
ADDI4
ASGNI4
ADDRGP4 $740
JUMPV
LABELV $739
line 2113
;2111:
;2112:    while (zpadlen-- > 0)
;2113:      total += dopr_outch (buffer, currlen, maxlen, '0');
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRFP4 8
INDIRI4
ARGI4
CNSTI4 48
ARGI4
ADDRLP4 120
ADDRGP4 dopr_outch
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 4
INDIRI4
ADDRLP4 120
INDIRI4
ADDI4
ASGNI4
LABELV $740
line 2112
ADDRLP4 124
ADDRLP4 68
INDIRI4
ASGNI4
ADDRLP4 68
ADDRLP4 124
INDIRI4
CNSTI4 1
SUBI4
ASGNI4
ADDRLP4 124
INDIRI4
CNSTI4 0
GTI4 $739
ADDRGP4 $743
JUMPV
LABELV $742
line 2116
;2114:
;2115:    while (fplace > 0) 
;2116:      total += dopr_outch (buffer, currlen, maxlen, fconvert[--fplace]);
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRFP4 8
INDIRI4
ARGI4
ADDRLP4 128
ADDRLP4 20
INDIRI4
CNSTI4 1
SUBI4
ASGNI4
ADDRLP4 20
ADDRLP4 128
INDIRI4
ASGNI4
ADDRLP4 128
INDIRI4
ADDRLP4 48
ADDP4
INDIRI1
CVII4 1
ARGI4
ADDRLP4 132
ADDRGP4 dopr_outch
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 4
INDIRI4
ADDRLP4 132
INDIRI4
ADDI4
ASGNI4
LABELV $743
line 2115
ADDRLP4 20
INDIRI4
CNSTI4 0
GTI4 $742
line 2117
;2117:  }
ADDRGP4 $746
JUMPV
LABELV $745
line 2120
;2118:
;2119:  while (padlen < 0) 
;2120:  {
line 2121
;2121:    total += dopr_outch (buffer, currlen, maxlen, ' ');
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRFP4 8
INDIRI4
ARGI4
CNSTI4 32
ARGI4
ADDRLP4 116
ADDRGP4 dopr_outch
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 4
INDIRI4
ADDRLP4 116
INDIRI4
ADDI4
ASGNI4
line 2122
;2122:    ++padlen;
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
line 2123
;2123:  }
LABELV $746
line 2119
ADDRLP4 0
INDIRI4
CNSTI4 0
LTI4 $745
line 2125
;2124:
;2125:  return total;
ADDRLP4 4
INDIRI4
RETI4
LABELV $682
endproc fmtfp 136 16
proc dopr_outch 8 0
ADDRFP4 12
ADDRFP4 12
INDIRI4
CVII1 4
ASGNI1
line 2129
;2126:}
;2127:
;2128:static int dopr_outch (char *buffer, size_t *currlen, size_t maxlen, char c)
;2129:{
line 2130
;2130:  if (*currlen + 1 < maxlen)
ADDRFP4 4
INDIRP4
INDIRI4
CNSTI4 1
ADDI4
ADDRFP4 8
INDIRI4
GEI4 $749
line 2131
;2131:    buffer[(*currlen)++] = c;
ADDRLP4 4
ADDRFP4 4
INDIRP4
ASGNP4
ADDRLP4 0
ADDRLP4 4
INDIRP4
INDIRI4
ASGNI4
ADDRLP4 4
INDIRP4
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
ADDRLP4 0
INDIRI4
ADDRFP4 0
INDIRP4
ADDP4
ADDRFP4 12
INDIRI1
ASGNI1
LABELV $749
line 2132
;2132:  return 1;
CNSTI4 1
RETI4
LABELV $748
endproc dopr_outch 8 0
export Q_vsnprintf
proc Q_vsnprintf 4 16
line 2136
;2133:}
;2134:
;2135:int Q_vsnprintf(char *str, size_t length, const char *fmt, va_list args)
;2136:{
line 2137
;2137:	if (str != NULL)
ADDRFP4 0
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $752
line 2138
;2138:		str[0] = 0;
ADDRFP4 0
INDIRP4
CNSTI1 0
ASGNI1
LABELV $752
line 2139
;2139:	return dopr(str, length, fmt, args);
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 4
INDIRI4
ARGI4
ADDRFP4 8
INDIRP4
ARGP4
ADDRFP4 12
INDIRP4
ARGP4
ADDRLP4 0
ADDRGP4 dopr
CALLI4
ASGNI4
ADDRLP4 0
INDIRI4
RETI4
LABELV $751
endproc Q_vsnprintf 4 16
export Q_snprintf
proc Q_snprintf 12 16
line 2143
;2140:}
;2141:
;2142:int Q_snprintf(char *str, size_t length, const char *fmt, ...)
;2143:{
line 2147
;2144:	va_list ap;
;2145:	int retval;
;2146:
;2147:	va_start(ap, fmt);
ADDRLP4 0
ADDRFP4 8+4
ASGNP4
line 2148
;2148:	retval = Q_vsnprintf(str, length, fmt, ap);
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 4
INDIRI4
ARGI4
ADDRFP4 8
INDIRP4
ARGP4
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 8
ADDRGP4 Q_vsnprintf
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 8
INDIRI4
ASGNI4
line 2149
;2149:	va_end(ap);
ADDRLP4 0
CNSTP4 0
ASGNP4
line 2151
;2150:	
;2151:	return retval;
ADDRLP4 4
INDIRI4
RETI4
LABELV $754
endproc Q_snprintf 12 16
export sscanf
proc sscanf 88 4
line 2155
;2152:}
;2153:
;2154:/* this is really crappy */
;2155:int sscanf( const char *buffer, const char *fmt, ... ) {
line 2161
;2156:	int		cmd;
;2157:	va_list		ap;
;2158:	int		count;
;2159:	size_t		len;
;2160:
;2161:	va_start (ap, fmt);
ADDRLP4 8
ADDRFP4 4+4
ASGNP4
line 2162
;2162:	count = 0;
ADDRLP4 12
CNSTI4 0
ASGNI4
ADDRGP4 $759
JUMPV
LABELV $758
line 2164
;2163:
;2164:	while ( *fmt ) {
line 2165
;2165:		if ( fmt[0] != '%' ) {
ADDRFP4 4
INDIRP4
INDIRI1
CVII4 1
CNSTI4 37
EQI4 $761
line 2166
;2166:			fmt++;
ADDRFP4 4
ADDRFP4 4
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 2167
;2167:			continue;
ADDRGP4 $759
JUMPV
LABELV $761
line 2170
;2168:		}
;2169:
;2170:		fmt++;
ADDRFP4 4
ADDRFP4 4
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 2171
;2171:		cmd = *fmt;
ADDRLP4 0
ADDRFP4 4
INDIRP4
INDIRI1
CVII4 1
ASGNI4
line 2173
;2172:
;2173:		if (isdigit (cmd)) {
ADDRLP4 0
INDIRI4
CNSTI4 48
LTI4 $763
ADDRLP4 0
INDIRI4
CNSTI4 57
GTI4 $763
line 2174
;2174:			len = (size_t)_atoi (&fmt);
ADDRFP4 4
ARGP4
ADDRLP4 20
ADDRGP4 _atoi
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 20
INDIRI4
ASGNI4
line 2175
;2175:			cmd = *(fmt - 1);
ADDRLP4 0
ADDRFP4 4
INDIRP4
CNSTI4 -1
ADDP4
INDIRI1
CVII4 1
ASGNI4
line 2176
;2176:		} else {
ADDRGP4 $764
JUMPV
LABELV $763
line 2177
;2177:			len = MAX_STRING_CHARS - 1;
ADDRLP4 4
CNSTI4 1023
ASGNI4
line 2178
;2178:			fmt++;
ADDRFP4 4
ADDRFP4 4
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 2179
;2179:		}
LABELV $764
line 2181
;2180:
;2181:		switch ( cmd ) {
ADDRLP4 24
CNSTI4 100
ASGNI4
ADDRLP4 0
INDIRI4
ADDRLP4 24
INDIRI4
EQI4 $767
ADDRLP4 0
INDIRI4
CNSTI4 102
EQI4 $768
ADDRLP4 0
INDIRI4
CNSTI4 105
EQI4 $767
ADDRLP4 0
INDIRI4
ADDRLP4 24
INDIRI4
LTI4 $765
LABELV $778
ADDRLP4 0
INDIRI4
CNSTI4 115
EQI4 $769
ADDRLP4 0
INDIRI4
CNSTI4 117
EQI4 $767
ADDRGP4 $765
JUMPV
LABELV $767
line 2185
;2182:		case 'i':
;2183:		case 'd':
;2184:		case 'u':
;2185:			*(va_arg (ap, int *)) = _atoi( &buffer );
ADDRLP4 32
ADDRLP4 8
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRLP4 8
ADDRLP4 32
INDIRP4
ASGNP4
ADDRFP4 0
ARGP4
ADDRLP4 36
ADDRGP4 _atoi
CALLI4
ASGNI4
ADDRLP4 32
INDIRP4
CNSTI4 -4
ADDP4
INDIRP4
ADDRLP4 36
INDIRI4
ASGNI4
line 2186
;2186:			break;
ADDRGP4 $766
JUMPV
LABELV $768
line 2188
;2187:		case 'f':
;2188:			*(va_arg (ap, float *)) = _atof( &buffer );
ADDRLP4 40
ADDRLP4 8
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRLP4 8
ADDRLP4 40
INDIRP4
ASGNP4
ADDRFP4 0
ARGP4
ADDRLP4 44
ADDRGP4 _atof
CALLF4
ASGNF4
ADDRLP4 40
INDIRP4
CNSTI4 -4
ADDP4
INDIRP4
ADDRLP4 44
INDIRF4
ASGNF4
line 2189
;2189:			break;
ADDRGP4 $766
JUMPV
LABELV $769
line 2191
;2190:		case 's':
;2191:			{
line 2192
;2192:			char *s = va_arg (ap, char *);
ADDRLP4 52
ADDRLP4 8
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRLP4 8
ADDRLP4 52
INDIRP4
ASGNP4
ADDRLP4 48
ADDRLP4 52
INDIRP4
CNSTI4 -4
ADDP4
INDIRP4
ASGNP4
ADDRGP4 $771
JUMPV
LABELV $770
line 2194
;2193:			while (isspace (*buffer))
;2194:				buffer++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
LABELV $771
line 2193
ADDRLP4 56
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 56
INDIRI4
CNSTI4 32
EQI4 $770
ADDRLP4 56
INDIRI4
CNSTI4 12
EQI4 $770
ADDRLP4 56
INDIRI4
CNSTI4 10
EQI4 $770
ADDRLP4 56
INDIRI4
CNSTI4 13
EQI4 $770
ADDRLP4 56
INDIRI4
CNSTI4 9
EQI4 $770
ADDRLP4 56
INDIRI4
CNSTI4 11
EQI4 $770
ADDRGP4 $774
JUMPV
LABELV $773
line 2196
;2195:			while (*buffer && !isspace (*buffer) && len-- > 0 )
;2196:				*s++ = *buffer++;
ADDRLP4 60
ADDRLP4 48
INDIRP4
ASGNP4
ADDRLP4 68
CNSTI4 1
ASGNI4
ADDRLP4 48
ADDRLP4 60
INDIRP4
ADDRLP4 68
INDIRI4
ADDP4
ASGNP4
ADDRLP4 64
ADDRFP4 0
INDIRP4
ASGNP4
ADDRFP4 0
ADDRLP4 64
INDIRP4
ADDRLP4 68
INDIRI4
ADDP4
ASGNP4
ADDRLP4 60
INDIRP4
ADDRLP4 64
INDIRP4
INDIRI1
ASGNI1
LABELV $774
line 2195
ADDRLP4 76
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 80
CNSTI4 0
ASGNI4
ADDRLP4 76
INDIRI4
ADDRLP4 80
INDIRI4
EQI4 $777
ADDRLP4 76
INDIRI4
CNSTI4 32
EQI4 $777
ADDRLP4 76
INDIRI4
CNSTI4 12
EQI4 $777
ADDRLP4 76
INDIRI4
CNSTI4 10
EQI4 $777
ADDRLP4 76
INDIRI4
CNSTI4 13
EQI4 $777
ADDRLP4 76
INDIRI4
CNSTI4 9
EQI4 $777
ADDRLP4 76
INDIRI4
CNSTI4 11
EQI4 $777
ADDRLP4 72
ADDRLP4 4
INDIRI4
ASGNI4
ADDRLP4 4
ADDRLP4 72
INDIRI4
CNSTI4 1
SUBI4
ASGNI4
ADDRLP4 72
INDIRI4
ADDRLP4 80
INDIRI4
GTI4 $773
LABELV $777
line 2197
;2197:			*s++ = '\0';
ADDRLP4 84
ADDRLP4 48
INDIRP4
ASGNP4
ADDRLP4 48
ADDRLP4 84
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 84
INDIRP4
CNSTI1 0
ASGNI1
line 2198
;2198:			break;
LABELV $765
LABELV $766
line 2201
;2199:			}
;2200:		}
;2201:	}
LABELV $759
line 2164
ADDRFP4 4
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $758
line 2203
;2202:
;2203:	va_end (ap);
ADDRLP4 8
CNSTP4 0
ASGNP4
line 2204
;2204:	return count;
ADDRLP4 12
INDIRI4
RETI4
LABELV $756
endproc sscanf 88 4
import COM_LoadLevelScores
import COM_CalculatePlayerScore
import Com_Printf
import Com_Error
import Info_NextPair
import Info_Validate
import Info_SetValueForKey_Big
import Info_SetValueForKey
import Info_RemoveKey_big
import Info_RemoveKey
import Info_ValueForKey
import vectoyaw
import AngleDifference
import Com_TruncateLongString
import va
import Q_CountChar
import Q_CleanStr
import Q_PrintStrlen
import Q_strcat
import Q_strncpyz
import Q_stristr
import Q_strupr
import Q_strlwr
import Q_stricmpn
import Q_strncmp
import Q_stricmp
import Q_isalpha
import Q_isupper
import Q_islower
import Q_isprint
import Com_RandomBytes
import Com_SkipCharset
import Com_SkipTokens
import Com_sprintf
import Parse3DMatrix
import Parse2DMatrix
import Parse1DMatrix
import SkipRestOfLine
import SkipBracedSection
import COM_MatchToken
import COM_ParseWarning
import COM_ParseError
import COM_Compress
import COM_ParseExt
import COM_Parse
import COM_GetCurrentParseLine
import COM_BeginParseSession
import COM_DefaultExtension
import COM_StripExtension
import COM_GetExtension
import COM_SkipPath
import Com_Clamp
import Q_isnan
import PerpendicularVector
import AngleVectors
import MatrixMultiply
import MakeNormalVectors
import RotateAroundDirection
import RotatePointAroundVector
import ProjectPointOnPlane
import PlaneFromPoints
import AngleDelta
import AngleNormalize180
import AngleNormalize360
import AnglesSubtract
import AngleSubtract
import LerpAngle
import AngleMod
import BoundsIntersectPoint
import BoundsIntersectSphere
import BoundsIntersect
import BoxOnPlaneSide
import SetPlaneSignbits
import AxisCopy
import AxisClear
import Lerp
import VelocityToAxis
import AnglesToAxis
import vectoangles
import Q_crandom
import Q_random
import Q_rand
import Q_acos
import Q_log2
import VectorRotate
import Vector4Scale
import VectorNormalize2
import VectorNormalize
import CrossProduct
import VectorInverse
import VectorNormalizeFast
import DistanceSquared
import Distance
import VectorLengthSquared
import VectorLength
import VectorCompare
import AddPointToBounds
import ClearBounds
import RadiusFromBounds
import NormalizeColor
import ColorBytes4
import ColorBytes3
import _VectorMA
import _VectorScale
import _VectorCopy
import _VectorAdd
import _VectorSubtract
import _DotProduct
import ByteToDir
import DirToByte
import ClampShort
import ClampChar
import Q_rsqrt
import Q_fabs
import axisDefault
import vec3_origin
import g_color_table
import colorDkGrey
import colorMdGrey
import colorLtGrey
import colorWhite
import colorCyan
import colorMagenta
import colorYellow
import colorBlue
import colorGreen
import colorRed
import colorBlack
import bytedirs
import Hunk_Alloc
import FloatSwap
import LongSwap
import ShortSwap
import acos
import atan2
import cos
import sin
import sqrt
import floor
import ceil
import memcpy
import memset
import strncpy
lit
align 1
LABELV $632
byte 1 48
byte 1 49
byte 1 50
byte 1 51
byte 1 52
byte 1 53
byte 1 54
byte 1 55
byte 1 56
byte 1 57
byte 1 97
byte 1 98
byte 1 99
byte 1 100
byte 1 101
byte 1 102
byte 1 0
align 1
LABELV $631
byte 1 48
byte 1 49
byte 1 50
byte 1 51
byte 1 52
byte 1 53
byte 1 54
byte 1 55
byte 1 56
byte 1 57
byte 1 65
byte 1 66
byte 1 67
byte 1 68
byte 1 69
byte 1 70
byte 1 0
align 1
LABELV $597
byte 1 60
byte 1 78
byte 1 85
byte 1 76
byte 1 76
byte 1 62
byte 1 0
align 1
LABELV $301
byte 1 48
byte 1 120
byte 1 0
align 1
LABELV $294
byte 1 105
byte 1 110
byte 1 105
byte 1 116
byte 1 121
byte 1 0
align 1
LABELV $289
byte 1 105
byte 1 110
byte 1 102
byte 1 0
align 1
LABELV $278
byte 1 110
byte 1 97
byte 1 110
byte 1 0
